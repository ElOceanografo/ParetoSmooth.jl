{
    "sourceFile": "test/runtests.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1626487596905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626563993088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n+using AxisKeys\n+using MCMCChains\n using ParetoSmooth\n+using Statistics\n using Test\n-using Statistics\n-using AxisKeys\n+using Turing\n \n import RData\n \n \n@@ -89,4 +91,85 @@\n     # Test for calling correct method\n     @test jul_loo.psis_object.weights ≈ psis(-log_lik_arr).weights\n     @test r_eff_loo.psis_object.weights ≈ psis(-log_lik_arr, r_eff).weights\n end\n+\n+\n+@testset \"MCMCChains and Turing utilities\" begin\n+    using Distributions, Random\n+    Random.seed!(112)\n+    # simulated samples for μ\n+    samples = randn(1000, 1, 3)\n+    data = randn(50)\n+    chain = Chains(samples)\n+\n+    function compute_loglike(μ, data)\n+        return logpdf(Normal(μ, 1), data)\n+    end\n+\n+    pll1 = pointwise_log_likelihoods(compute_loglike, chain, data)\n+    pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)\n+    # the pointwise log likehoods should be the same for both methods\n+    @test pll1 ≈ pll2 atol = 1e-6\n+    # test the dimensions: data points, samples, chains\n+    @test size(pll1) == (50, 1000, 3)\n+    # test that sum of pointwise log likelihoods equals sum of log likelihoods\n+    @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pll1) atol = 1e6\n+    # test that psis_loo works with MCMCChains and yields correct type\n+    psis_loo_output = psis_loo(compute_loglike, chain, data)\n+    @test isa(psis_loo_output, PsisLoo)\n+    # test that loo works with MCMCChains and yields correct type\n+    psis_output = loo(compute_loglike, chain, data)\n+    @test isa(psis_output, PsisLoo)\n+    # test that psis works with MCMCChains and yields correct type\n+    psis_output = psis(compute_loglike, chain, data)\n+    @test isa(psis_output, Psis)\n+\n+    # ensure that methods work with r_eff argument\n+    r_eff = similar(pll2, 0)\n+    # test that psis_loo works with MCMCChains and yields correct type\n+    psis_loo_output = psis_loo(compute_loglike, chain, data, r_eff)\n+    @test isa(psis_loo_output, PsisLoo)\n+    # test that loo works with MCMCChains and yields correct type\n+    psis_output = loo(compute_loglike, chain, data, r_eff)\n+    @test isa(psis_output, PsisLoo)\n+    # test that psis works with MCMCChains and yields correct type\n+    psis_output = psis(compute_loglike, chain, data, r_eff)\n+    @test isa(psis_output, Psis)\n+\n+    @model function model(data)\n+        μ ~ Normal(0, 1)\n+        σ ~ truncated(Cauchy(0, 1), 0, Inf)\n+        for i in eachindex(data)\n+            data[i] ~ Normal(μ, σ)\n+        end\n+    end\n+\n+    chain = sample(model(data), NUTS(1000, .65), MCMCThreads(), 1000, 4)\n+    pw_lls = pointwise_log_likelihoods(chain, model(data))\n+    # test the dimensions: data points, samples, chains\n+    @test size(pw_lls) == (50, 1000, 4)\n+    # test that sum of pointwise log likelihoods equals sum of log likelihoods\n+    @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pw_lls) atol = 1e6\n+\n+    # test that psis_loo works with Turing model and MCMCChains and yields correct type\n+    psis_loo_output = psis_loo(model(data), chain)\n+    @test isa(psis_loo_output, PsisLoo)\n+    # test that loo works with Turing model and MCMCChains and yields correct type\n+    psis_output = loo(model(data), chain)\n+    @test isa(psis_output, PsisLoo)\n+    # test that psis works with Turing model and MCMCChains and yields correct type\n+    psis_output = psis(model(data), chain)\n+    @test isa(psis_output, Psis)\n+\n+    # ensure that methods work with r_eff argument\n+    r_eff = similar(pw_lls, 0)\n+    # test that psis_loo works with Turing model and MCMCChains and yields correct type\n+    psis_loo_output = psis_loo(model(data), chain, r_eff)\n+    @test isa(psis_loo_output, PsisLoo)\n+    # test that loo works with Turing model and MCMCChains and yields correct type\n+    psis_output = loo(model(data), chain, r_eff)\n+    @test isa(psis_output, PsisLoo)\n+    # test that psis works with Turing model and MCMCChains and yields correct type\n+    psis_output = psis(model(data), chain, r_eff)\n+    @test isa(psis_output, Psis)\n+end\n"
                },
                {
                    "date": 1626564639796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n @testset \"MCMCChains and Turing utilities\" begin\n     using Distributions, Random\n     Random.seed!(112)\n     # simulated samples for μ\n-    samples = randn(1000, 1, 3)\n+    samples = randn(1, 100, 3)\n     data = randn(50)\n     chain = Chains(samples)\n \n     function compute_loglike(μ, data)\n"
                },
                {
                    "date": 1626569084197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,9 +110,9 @@\n     pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)\n     # the pointwise log likehoods should be the same for both methods\n     @test pll1 ≈ pll2 atol = 1e-6\n     # test the dimensions: data points, samples, chains\n-    @test size(pll1) == (50, 1000, 3)\n+    @test size(pll1) == (50, 100, 3)\n     # test that sum of pointwise log likelihoods equals sum of log likelihoods\n     @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pll1) atol = 1e6\n     # test that psis_loo works with MCMCChains and yields correct type\n     psis_loo_output = psis_loo(compute_loglike, chain, data)\n"
                },
                {
                    "date": 1626569195410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n @testset \"MCMCChains and Turing utilities\" begin\n     using Distributions, Random\n     Random.seed!(112)\n     # simulated samples for μ\n-    samples = randn(1, 100, 3)\n+    samples = randn(1, 100, 1)\n     data = randn(50)\n     chain = Chains(samples)\n \n     function compute_loglike(μ, data)\n@@ -110,9 +110,9 @@\n     pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)\n     # the pointwise log likehoods should be the same for both methods\n     @test pll1 ≈ pll2 atol = 1e-6\n     # test the dimensions: data points, samples, chains\n-    @test size(pll1) == (50, 100, 3)\n+    @test size(pll1) == (50, 100, 1)\n     # test that sum of pointwise log likelihoods equals sum of log likelihoods\n     @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pll1) atol = 1e6\n     # test that psis_loo works with MCMCChains and yields correct type\n     psis_loo_output = psis_loo(compute_loglike, chain, data)\n"
                },
                {
                    "date": 1626569260893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,9 +146,9 @@\n \n     chain = sample(model(data), NUTS(1000, .65), MCMCThreads(), 1000, 4)\n     pw_lls = pointwise_log_likelihoods(chain, model(data))\n     # test the dimensions: data points, samples, chains\n-    @test size(pw_lls) == (50, 1000, 4)\n+    @test size(pw_lls) == (50, 100, 4)\n     # test that sum of pointwise log likelihoods equals sum of log likelihoods\n     @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pw_lls) atol = 1e6\n \n     # test that psis_loo works with Turing model and MCMCChains and yields correct type\n"
                },
                {
                    "date": 1626570096301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,9 +146,9 @@\n \n     chain = sample(model(data), NUTS(1000, .65), MCMCThreads(), 1000, 4)\n     pw_lls = pointwise_log_likelihoods(chain, model(data))\n     # test the dimensions: data points, samples, chains\n-    @test size(pw_lls) == (50, 100, 4)\n+    @test size(pw_lls) == (50, 1000, 4)\n     # test that sum of pointwise log likelihoods equals sum of log likelihoods\n     @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pw_lls) atol = 1e6\n \n     # test that psis_loo works with Turing model and MCMCChains and yields correct type\n"
                },
                {
                    "date": 1626621800797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,9 +144,9 @@\n         end\n     end\n \n     chain = sample(model(data), NUTS(1000, .65), MCMCThreads(), 1000, 4)\n-    pw_lls = pointwise_log_likelihoods(chain, model(data))\n+    pw_lls = pointwise_log_likelihoods(model(data), chain)\n     # test the dimensions: data points, samples, chains\n     @test size(pw_lls) == (50, 1000, 4)\n     # test that sum of pointwise log likelihoods equals sum of log likelihoods\n     @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pw_lls) atol = 1e6\n"
                },
                {
                    "date": 1626623499226,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -171,5 +171,6 @@\n     @test isa(psis_output, PsisLoo)\n     # test that psis works with Turing model and MCMCChains and yields correct type\n     psis_output = psis(model(data), chain, r_eff)\n     @test isa(psis_output, Psis)\n+\n end\n"
                },
                {
                    "date": 1626625951507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,9 +143,9 @@\n             data[i] ~ Normal(μ, σ)\n         end\n     end\n \n-    chain = sample(model(data), NUTS(1000, .65), MCMCThreads(), 1000, 4)\n+    chain = sample(model(data), NUTS(1000, .9), MCMCThreads(), 1000, 4)\n     pw_lls = pointwise_log_likelihoods(model(data), chain)\n     # test the dimensions: data points, samples, chains\n     @test size(pw_lls) == (50, 1000, 4)\n     # test that sum of pointwise log likelihoods equals sum of log likelihoods\n"
                },
                {
                    "date": 1626626230155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,144 +33,145 @@\n                             )\n r_loo[\"estimates\"](criterion=:avg_score) .= \n     r_loo[\"estimates\"](criterion=:total_score) / size(r_loo[\"pointwise\"], 1)\n \n-\n @testset \"ParetoSmooth.jl\" begin\n+    @testset \"Basic Arrays\" begin\n \n-    # All of these should run\n-    with_r_eff = psis(log_lik_arr, r_eff)\n-    jul_psis = psis(log_lik_arr)\n-    log_lik_mat = reshape(log_lik_arr, 32, 1000)\n-    chain_index = vcat(fill(1, 500), fill(2, 500))\n-    matrix_psis = psis(log_lik_mat; chain_index=chain_index)\n-    log_psis = psis(log_lik_arr; log_weights=true)\n+        # All of these should run\n+        with_r_eff = psis(log_lik_arr, r_eff)\n+        jul_psis = psis(log_lik_arr)\n+        log_lik_mat = reshape(log_lik_arr, 32, 1000)\n+        chain_index = vcat(fill(1, 500), fill(2, 500))\n+        matrix_psis = psis(log_lik_mat; chain_index=chain_index)\n+        log_psis = psis(log_lik_arr; log_weights=true)\n \n-    jul_loo = loo(log_lik_arr)\n-    r_eff_loo = psis_loo(log_lik_arr, r_eff)\n+        jul_loo = loo(log_lik_arr)\n+        r_eff_loo = psis_loo(log_lik_arr, r_eff)\n \n-    display(jul_loo)\n-    \n-    # max 10% difference in tail length calc between Julia and R\n-    @test maximum(abs.(log.(jul_psis.tail_len ./ r_tail_len))) ≤ .1\n-    @test maximum(abs.(jul_psis.tail_len .- r_tail_len)) ≤ 10\n-    @test maximum(abs.(with_r_eff.tail_len .- r_tail_len)) ≤ 1\n-    \n-    # RMSE from R version is less than .1%\n-    @test sqrt(mean((with_r_eff.weights ./ r_weights .- 1).^2)) ≤ .001\n-    # RMSE less than .2% when using InferenceDiagnostics' ESS\n-    @test sqrt(mean((jul_psis.weights ./ r_weights .- 1).^2)) ≤ .002\n-    # Max difference is 1%\n-    @test maximum(log_psis.weights .- log.(r_weights)) ≤ .01\n+        display(jul_loo)\n+        \n+        # max 10% difference in tail length calc between Julia and R\n+        @test maximum(abs.(log.(jul_psis.tail_len ./ r_tail_len))) ≤ .1\n+        @test maximum(abs.(jul_psis.tail_len .- r_tail_len)) ≤ 10\n+        @test maximum(abs.(with_r_eff.tail_len .- r_tail_len)) ≤ 1\n+        \n+        # RMSE from R version is less than .1%\n+        @test sqrt(mean((with_r_eff.weights ./ r_weights .- 1).^2)) ≤ .001\n+        # RMSE less than .2% when using InferenceDiagnostics' ESS\n+        @test sqrt(mean((jul_psis.weights ./ r_weights .- 1).^2)) ≤ .002\n+        # Max difference is 1%\n+        @test maximum(log_psis.weights .- log.(r_weights)) ≤ .01\n \n \n-    ## Test difference in loo pointwise results\n+        ## Test difference in loo pointwise results\n \n-    # Different r_eff\n-    errs = (r_loo[\"pointwise\"] - jul_loo.pointwise).^2\n-    @test sqrt(mean(errs(:est_score))) ≤ .01\n-    @test sqrt(mean(errs(:est_overfit))) ≤ .01\n-    @test sqrt(mean(errs(:pareto_k))) ≤ .05\n-    errs_mcse = log.(r_loo[\"pointwise\"](:mcse) ./ jul_loo.pointwise(:mcse)).^2\n-    # @test sqrt(mean(errs_mcse)) ≤ .1\n+        # Different r_eff\n+        errs = (r_loo[\"pointwise\"] - jul_loo.pointwise).^2\n+        @test sqrt(mean(errs(:est_score))) ≤ .01\n+        @test sqrt(mean(errs(:est_overfit))) ≤ .01\n+        @test sqrt(mean(errs(:pareto_k))) ≤ .05\n+        errs_mcse = log.(r_loo[\"pointwise\"](:mcse) ./ jul_loo.pointwise(:mcse)).^2\n+        # @test sqrt(mean(errs_mcse)) ≤ .1\n \n-    # Same r_eff\n-    errs = (r_loo[\"pointwise\"] - r_eff_loo.pointwise).^2\n-    @test sqrt(mean(errs(:est_score))) ≤ .01\n-    @test sqrt(mean(errs(:est_overfit))) ≤ .01\n-    @test sqrt(mean(errs(:pareto_k))) ≤ .05\n-    errs_mcse = log.(r_loo[\"pointwise\"](:mcse) ./ r_eff_loo.pointwise(:mcse)).^2\n-    # @test sqrt(mean(errs_mcse)) ≤ .1\n-    \n-    # Test estimates\n-    errs = r_loo[\"estimates\"] - jul_loo.estimates\n-    @test maximum(abs.(errs)) ≤ .01\n-    \n-    errs = r_loo[\"estimates\"] - r_eff_loo.estimates\n-    @test maximum(abs.(errs)) ≤ .01\n+        # Same r_eff\n+        errs = (r_loo[\"pointwise\"] - r_eff_loo.pointwise).^2\n+        @test sqrt(mean(errs(:est_score))) ≤ .01\n+        @test sqrt(mean(errs(:est_overfit))) ≤ .01\n+        @test sqrt(mean(errs(:pareto_k))) ≤ .05\n+        errs_mcse = log.(r_loo[\"pointwise\"](:mcse) ./ r_eff_loo.pointwise(:mcse)).^2\n+        # @test sqrt(mean(errs_mcse)) ≤ .1\n+        \n+        # Test estimates\n+        errs = r_loo[\"estimates\"] - jul_loo.estimates\n+        @test maximum(abs.(errs)) ≤ .01\n+        \n+        errs = r_loo[\"estimates\"] - r_eff_loo.estimates\n+        @test maximum(abs.(errs)) ≤ .01\n \n-    # Test for calling correct method\n-    @test jul_loo.psis_object.weights ≈ psis(-log_lik_arr).weights\n-    @test r_eff_loo.psis_object.weights ≈ psis(-log_lik_arr, r_eff).weights\n-end\n+        # Test for calling correct method\n+        @test jul_loo.psis_object.weights ≈ psis(-log_lik_arr).weights\n+        @test r_eff_loo.psis_object.weights ≈ psis(-log_lik_arr, r_eff).weights\n+    end\n \n \n-@testset \"MCMCChains and Turing utilities\" begin\n-    using Distributions, Random\n-    Random.seed!(112)\n-    # simulated samples for μ\n-    samples = randn(1, 100, 1)\n-    data = randn(50)\n-    chain = Chains(samples)\n+    @testset \"MCMCChains and Turing utilities\" begin\n+        using Distributions, Random\n+        Random.seed!(112)\n+        # simulated samples for μ\n+        samples = randn(1, 100, 1)\n+        data = randn(50)\n+        chain = Chains(samples)\n \n-    function compute_loglike(μ, data)\n-        return logpdf(Normal(μ, 1), data)\n-    end\n+        function compute_loglike(μ, data)\n+            return logpdf(Normal(μ, 1), data)\n+        end\n \n-    pll1 = pointwise_log_likelihoods(compute_loglike, chain, data)\n-    pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)\n-    # the pointwise log likehoods should be the same for both methods\n-    @test pll1 ≈ pll2 atol = 1e-6\n-    # test the dimensions: data points, samples, chains\n-    @test size(pll1) == (50, 100, 1)\n-    # test that sum of pointwise log likelihoods equals sum of log likelihoods\n-    @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pll1) atol = 1e6\n-    # test that psis_loo works with MCMCChains and yields correct type\n-    psis_loo_output = psis_loo(compute_loglike, chain, data)\n-    @test isa(psis_loo_output, PsisLoo)\n-    # test that loo works with MCMCChains and yields correct type\n-    psis_output = loo(compute_loglike, chain, data)\n-    @test isa(psis_output, PsisLoo)\n-    # test that psis works with MCMCChains and yields correct type\n-    psis_output = psis(compute_loglike, chain, data)\n-    @test isa(psis_output, Psis)\n+        pll1 = pointwise_log_likelihoods(compute_loglike, chain, data)\n+        pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)\n+        # the pointwise log likehoods should be the same for both methods\n+        @test pll1 ≈ pll2 atol = 1e-6\n+        # test the dimensions: data points, samples, chains\n+        @test size(pll1) == (50, 100, 1)\n+        # test that sum of pointwise log likelihoods equals sum of log likelihoods\n+        @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pll1) atol = 1e6\n+        # test that psis_loo works with MCMCChains and yields correct type\n+        psis_loo_output = psis_loo(compute_loglike, chain, data)\n+        @test isa(psis_loo_output, PsisLoo)\n+        # test that loo works with MCMCChains and yields correct type\n+        psis_output = loo(compute_loglike, chain, data)\n+        @test isa(psis_output, PsisLoo)\n+        # test that psis works with MCMCChains and yields correct type\n+        psis_output = psis(compute_loglike, chain, data)\n+        @test isa(psis_output, Psis)\n \n-    # ensure that methods work with r_eff argument\n-    r_eff = similar(pll2, 0)\n-    # test that psis_loo works with MCMCChains and yields correct type\n-    psis_loo_output = psis_loo(compute_loglike, chain, data, r_eff)\n-    @test isa(psis_loo_output, PsisLoo)\n-    # test that loo works with MCMCChains and yields correct type\n-    psis_output = loo(compute_loglike, chain, data, r_eff)\n-    @test isa(psis_output, PsisLoo)\n-    # test that psis works with MCMCChains and yields correct type\n-    psis_output = psis(compute_loglike, chain, data, r_eff)\n-    @test isa(psis_output, Psis)\n+        # ensure that methods work with r_eff argument\n+        r_eff = similar(pll2, 0)\n+        # test that psis_loo works with MCMCChains and yields correct type\n+        psis_loo_output = psis_loo(compute_loglike, chain, data, r_eff)\n+        @test isa(psis_loo_output, PsisLoo)\n+        # test that loo works with MCMCChains and yields correct type\n+        psis_output = loo(compute_loglike, chain, data, r_eff)\n+        @test isa(psis_output, PsisLoo)\n+        # test that psis works with MCMCChains and yields correct type\n+        psis_output = psis(compute_loglike, chain, data, r_eff)\n+        @test isa(psis_output, Psis)\n \n-    @model function model(data)\n-        μ ~ Normal(0, 1)\n-        σ ~ truncated(Cauchy(0, 1), 0, Inf)\n-        for i in eachindex(data)\n-            data[i] ~ Normal(μ, σ)\n+        @model function model(data)\n+            μ ~ Normal(0, 1)\n+            σ ~ truncated(Cauchy(0, 1), 0, Inf)\n+            for i in eachindex(data)\n+                data[i] ~ Normal(μ, σ)\n+            end\n         end\n-    end\n \n-    chain = sample(model(data), NUTS(1000, .9), MCMCThreads(), 1000, 4)\n-    pw_lls = pointwise_log_likelihoods(model(data), chain)\n-    # test the dimensions: data points, samples, chains\n-    @test size(pw_lls) == (50, 1000, 4)\n-    # test that sum of pointwise log likelihoods equals sum of log likelihoods\n-    @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pw_lls) atol = 1e6\n+        chain = sample(model(data), NUTS(1000, .9), MCMCThreads(), 1000, 4)\n+        pw_lls = pointwise_log_likelihoods(model(data), chain)\n+        # test the dimensions: data points, samples, chains\n+        @test size(pw_lls) == (50, 1000, 4)\n+        # test that sum of pointwise log likelihoods equals sum of log likelihoods\n+        @test sum(sum(map(s->logpdf.(Normal(s, 1), data), samples))) ≈ sum(pw_lls) atol = 1e6\n \n-    # test that psis_loo works with Turing model and MCMCChains and yields correct type\n-    psis_loo_output = psis_loo(model(data), chain)\n-    @test isa(psis_loo_output, PsisLoo)\n-    # test that loo works with Turing model and MCMCChains and yields correct type\n-    psis_output = loo(model(data), chain)\n-    @test isa(psis_output, PsisLoo)\n-    # test that psis works with Turing model and MCMCChains and yields correct type\n-    psis_output = psis(model(data), chain)\n-    @test isa(psis_output, Psis)\n+        # test that psis_loo works with Turing model and MCMCChains and yields correct type\n+        psis_loo_output = psis_loo(model(data), chain)\n+        @test isa(psis_loo_output, PsisLoo)\n+        # test that loo works with Turing model and MCMCChains and yields correct type\n+        psis_output = loo(model(data), chain)\n+        @test isa(psis_output, PsisLoo)\n+        # test that psis works with Turing model and MCMCChains and yields correct type\n+        psis_output = psis(model(data), chain)\n+        @test isa(psis_output, Psis)\n \n-    # ensure that methods work with r_eff argument\n-    r_eff = similar(pw_lls, 0)\n-    # test that psis_loo works with Turing model and MCMCChains and yields correct type\n-    psis_loo_output = psis_loo(model(data), chain, r_eff)\n-    @test isa(psis_loo_output, PsisLoo)\n-    # test that loo works with Turing model and MCMCChains and yields correct type\n-    psis_output = loo(model(data), chain, r_eff)\n-    @test isa(psis_output, PsisLoo)\n-    # test that psis works with Turing model and MCMCChains and yields correct type\n-    psis_output = psis(model(data), chain, r_eff)\n-    @test isa(psis_output, Psis)\n+        # ensure that methods work with r_eff argument\n+        r_eff = similar(pw_lls, 0)\n+        # test that psis_loo works with Turing model and MCMCChains and yields correct type\n+        psis_loo_output = psis_loo(model(data), chain, r_eff)\n+        @test isa(psis_loo_output, PsisLoo)\n+        # test that loo works with Turing model and MCMCChains and yields correct type\n+        psis_output = loo(model(data), chain, r_eff)\n+        @test isa(psis_output, PsisLoo)\n+        # test that psis works with Turing model and MCMCChains and yields correct type\n+        psis_output = psis(model(data), chain, r_eff)\n+        @test isa(psis_output, Psis)\n \n+    end\n end\n"
                },
                {
                    "date": 1626629155206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,9 +159,10 @@\n         @test isa(psis_output, PsisLoo)\n         # test that psis works with Turing model and MCMCChains and yields correct type\n         psis_output = psis(model(data), chain)\n         @test isa(psis_output, Psis)\n-\n+    end\n+    @testset \"r_eff\" begin\n         # ensure that methods work with r_eff argument\n         r_eff = similar(pw_lls, 0)\n         # test that psis_loo works with Turing model and MCMCChains and yields correct type\n         psis_loo_output = psis_loo(model(data), chain, r_eff)\n"
                },
                {
                    "date": 1626629347737,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,8 +105,9 @@\n         function compute_loglike(μ, data)\n             return logpdf(Normal(μ, 1), data)\n         end\n \n+        \n         pll1 = pointwise_log_likelihoods(compute_loglike, chain, data)\n         pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)\n         # the pointwise log likehoods should be the same for both methods\n         @test pll1 ≈ pll2 atol = 1e-6\n@@ -159,20 +160,23 @@\n         @test isa(psis_output, PsisLoo)\n         # test that psis works with Turing model and MCMCChains and yields correct type\n         psis_output = psis(model(data), chain)\n         @test isa(psis_output, Psis)\n-    end\n-    @testset \"r_eff\" begin\n-        # ensure that methods work with r_eff argument\n-        r_eff = similar(pw_lls, 0)\n-        # test that psis_loo works with Turing model and MCMCChains and yields correct type\n-        psis_loo_output = psis_loo(model(data), chain, r_eff)\n-        @test isa(psis_loo_output, PsisLoo)\n-        # test that loo works with Turing model and MCMCChains and yields correct type\n-        psis_output = loo(model(data), chain, r_eff)\n-        @test isa(psis_output, PsisLoo)\n-        # test that psis works with Turing model and MCMCChains and yields correct type\n-        psis_output = psis(model(data), chain, r_eff)\n-        @test isa(psis_output, Psis)\n \n+\n+        @testset \"r_eff\" begin\n+            pw_lls = pointwise_log_likelihoods(model(data), chain)\n+            # ensure that methods work with r_eff argument\n+            r_eff = similar(pw_lls, 0)\n+            # test that psis_loo works with Turin and gives correct type\n+            psis_loo_output = psis_loo(model(data), chain, r_eff)\n+            @test isa(psis_loo_output, PsisLoo)\n+            # test that loo works with Turing model and MCMCChains and gives correct type\n+            psis_output = loo(model(data), chain, r_eff)\n+            @test isa(psis_output, PsisLoo)\n+            # test that psis works with Turing model and MCMCChains and gives correct type\n+            psis_output = psis(model(data), chain, r_eff)\n+            @test isa(psis_output, Psis)\n+\n+        end\n     end\n end\n"
                },
                {
                    "date": 1626630631931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -162,21 +162,19 @@\n         psis_output = psis(model(data), chain)\n         @test isa(psis_output, Psis)\n \n \n-        @testset \"r_eff\" begin\n-            pw_lls = pointwise_log_likelihoods(model(data), chain)\n-            # ensure that methods work with r_eff argument\n-            r_eff = similar(pw_lls, 0)\n-            # test that psis_loo works with Turin and gives correct type\n-            psis_loo_output = psis_loo(model(data), chain, r_eff)\n-            @test isa(psis_loo_output, PsisLoo)\n-            # test that loo works with Turing model and MCMCChains and gives correct type\n-            psis_output = loo(model(data), chain, r_eff)\n-            @test isa(psis_output, PsisLoo)\n-            # test that psis works with Turing model and MCMCChains and gives correct type\n-            psis_output = psis(model(data), chain, r_eff)\n-            @test isa(psis_output, Psis)\n+        \n+        # ensure that methods work with r_eff argument\n+        r_eff = similar(pw_lls, 0)\n+        # test that psis_loo works with Turin and gives correct type\n+        psis_loo_output = psis_loo(model(data), chain, r_eff)\n+        @test isa(psis_loo_output, PsisLoo)\n+        # test that loo works with Turing model and MCMCChains and gives correct type\n+        psis_output = loo(model(data), chain, r_eff)\n+        @test isa(psis_output, PsisLoo)\n+        # test that psis works with Turing model and MCMCChains and gives correct type\n+        psis_output = psis(model(data), chain, r_eff)\n+        @test isa(psis_output, Psis)\n \n-        end\n     end\n end\n"
                }
            ],
            "date": 1626487596905,
            "name": "Commit-0",
            "content": "using ParetoSmooth\nusing Test\nusing Statistics\nusing AxisKeys\n\nimport RData\n\n\nlet og_array = RData.load(\"Example_Log_Likelihood_Array.RData\")[\"x\"]\n    global log_lik_arr = copy(permutedims(og_array, [3, 1, 2]))\nend\nlet og_weights = RData.load(\"Weight_Matrix.RData\")[\"weightMatrix\"]\n    global r_weights = exp.(permutedims(reshape(og_weights, 500, 2, 32), [3, 1, 2]))\nend\nr_eff = RData.load(\"Rel_Eff.RData\")[\"rel_eff\"]\nr_psis = RData.load(\"Psis_Object.RData\")[\"x\"]\nr_tail_len = Int.(RData.load(\"Tail_Vector.RData\")[\"tail\"])\npareto_k = RData.load(\"Pareto_K.RData\")[\"pareto_k\"]\nr_loo = RData.load(\"Example_Loo.RData\")[\"example_loo\"]\n\n\n# Add labels, reformat\nr_loo[\"pointwise\"] = KeyedArray(r_loo[\"pointwise\"][:, Not(4)];\n                            data = 1:size(r_loo[\"pointwise\"], 1),\n                            statistic=[:est_score, :mcse, :est_overfit, :pareto_k],\n                        )\n\nr_loo[\"estimates\"] = KeyedArray(r_loo[\"estimates\"];\n                                criterion=[:total_score, :overfit, :avg_score],\n                                estimate=[:Estimate, :SE],\n                            )\nr_loo[\"estimates\"](criterion=:avg_score) .= \n    r_loo[\"estimates\"](criterion=:total_score) / size(r_loo[\"pointwise\"], 1)\n\n\n@testset \"ParetoSmooth.jl\" begin\n\n    # All of these should run\n    with_r_eff = psis(log_lik_arr, r_eff)\n    jul_psis = psis(log_lik_arr)\n    log_lik_mat = reshape(log_lik_arr, 32, 1000)\n    chain_index = vcat(fill(1, 500), fill(2, 500))\n    matrix_psis = psis(log_lik_mat; chain_index=chain_index)\n    log_psis = psis(log_lik_arr; log_weights=true)\n\n    jul_loo = loo(log_lik_arr)\n    r_eff_loo = psis_loo(log_lik_arr, r_eff)\n\n    display(jul_loo)\n    \n    # max 10% difference in tail length calc between Julia and R\n    @test maximum(abs.(log.(jul_psis.tail_len ./ r_tail_len))) ≤ .1\n    @test maximum(abs.(jul_psis.tail_len .- r_tail_len)) ≤ 10\n    @test maximum(abs.(with_r_eff.tail_len .- r_tail_len)) ≤ 1\n    \n    # RMSE from R version is less than .1%\n    @test sqrt(mean((with_r_eff.weights ./ r_weights .- 1).^2)) ≤ .001\n    # RMSE less than .2% when using InferenceDiagnostics' ESS\n    @test sqrt(mean((jul_psis.weights ./ r_weights .- 1).^2)) ≤ .002\n    # Max difference is 1%\n    @test maximum(log_psis.weights .- log.(r_weights)) ≤ .01\n\n\n    ## Test difference in loo pointwise results\n\n    # Different r_eff\n    errs = (r_loo[\"pointwise\"] - jul_loo.pointwise).^2\n    @test sqrt(mean(errs(:est_score))) ≤ .01\n    @test sqrt(mean(errs(:est_overfit))) ≤ .01\n    @test sqrt(mean(errs(:pareto_k))) ≤ .05\n    errs_mcse = log.(r_loo[\"pointwise\"](:mcse) ./ jul_loo.pointwise(:mcse)).^2\n    # @test sqrt(mean(errs_mcse)) ≤ .1\n\n    # Same r_eff\n    errs = (r_loo[\"pointwise\"] - r_eff_loo.pointwise).^2\n    @test sqrt(mean(errs(:est_score))) ≤ .01\n    @test sqrt(mean(errs(:est_overfit))) ≤ .01\n    @test sqrt(mean(errs(:pareto_k))) ≤ .05\n    errs_mcse = log.(r_loo[\"pointwise\"](:mcse) ./ r_eff_loo.pointwise(:mcse)).^2\n    # @test sqrt(mean(errs_mcse)) ≤ .1\n    \n    # Test estimates\n    errs = r_loo[\"estimates\"] - jul_loo.estimates\n    @test maximum(abs.(errs)) ≤ .01\n    \n    errs = r_loo[\"estimates\"] - r_eff_loo.estimates\n    @test maximum(abs.(errs)) ≤ .01\n\n    # Test for calling correct method\n    @test jul_loo.psis_object.weights ≈ psis(-log_lik_arr).weights\n    @test r_eff_loo.psis_object.weights ≈ psis(-log_lik_arr, r_eff).weights\nend\n"
        }
    ]
}