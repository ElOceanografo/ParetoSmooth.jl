{
    "sourceFile": "src/ESS.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 17,
            "patches": [
                {
                    "date": 1626309971342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626310317671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n using FFTW\n using MCMCDiagnosticTools\n using LoopVectorization\n-using TensorOperations\n using Tullio\n \n export relative_eff, psis_n_eff\n \n"
                },
                {
                    "date": 1626310325166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n function psis_n_eff(\n     weights::AbstractMatrix{T}, r_eff::AbstractVector{T}\n ) where {T<:AbstractFloat}\n     @tullio sum_of_squares[x] := weights[x, y]^2\n-    return @turbo r_eff ./ sum_of_squares\n+    return @tturbo r_eff ./ sum_of_squares\n end\n \n function psis_n_eff(weights::AbstractArray{T}) where {T<:AbstractFloat}\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n"
                },
                {
                    "date": 1626314405224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n using FFTW\n using MCMCDiagnosticTools\n using LoopVectorization\n+using TensorOperations\n using Tullio\n \n export relative_eff, psis_n_eff\n \n"
                },
                {
                    "date": 1626314567863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n using FFTW\n using MCMCDiagnosticTools\n using LoopVectorization\n-using TensorOperations\n using Tullio\n \n export relative_eff, psis_n_eff\n \n"
                },
                {
                    "date": 1626454088792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,14 +2,15 @@\n using MCMCDiagnosticTools\n using LoopVectorization\n using Tullio\n \n-export relative_eff, psis_n_eff\n+export relative_eff, psis_ess\n \n \"\"\"\n     relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=FFTESSMethod())\n \n-Compute the MCMC effective sample size divided by the nominal sample size.\n+Calculate the relative efficiency of an MCMC chain, i.e. the effective sample size divided\n+by the nominal sample size.\n \"\"\"\n function relative_eff(\n     sample::AbstractArray{T,3}; method=FFTESSMethod()\n ) where {T<:AbstractFloat}\n@@ -22,28 +23,37 @@\n     return r_eff\n end\n \n \"\"\"\n-    function psis_n_eff(\n+    function psis_ess(\n         weights::AbstractVector{T},\n         r_eff::AbstractVector{T}\n     ) -> AbstractVector{T}\n+\n+Calculate the (approximate) effective sample size of a PSIS sample, using the correction in\n+Vehtari et al. 2019.\n+\n+# Arguments\n+\n+- `weights`: A set of importance sampling weights derived from PSIS.\n+- `r_eff`: The relative efficiency of the MCMC chains from which PSIS samples were derived.\n+See `?relative_eff` to calculate `r_eff`.\n \"\"\"\n-function psis_n_eff(\n+function psis_ess(\n     weights::AbstractVector{T}, r_eff::AbstractVector{T}\n ) where {T<:AbstractFloat}\n     @tullio sum_of_squares := weights[x]^2\n     return r_eff ./ sum_of_squares\n end\n \n-function psis_n_eff(\n+function psis_ess(\n     weights::AbstractMatrix{T}, r_eff::AbstractVector{T}\n ) where {T<:AbstractFloat}\n     @tullio sum_of_squares[x] := weights[x, y]^2\n     return @tturbo r_eff ./ sum_of_squares\n end\n \n-function psis_n_eff(weights::AbstractArray{T}) where {T<:AbstractFloat}\n+function psis_ess(weights::AbstractArray{T}) where {T<:AbstractFloat}\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n-    return psis_n_eff(weights, ones(size(weights)))\n+    return psis_ess(weights, ones(size(weights)))\n end\n"
                },
                {
                    "date": 1626454315198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,4 +56,8 @@\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n+\n+function psis_n_eff(args...) \n+    psis_ess\n+end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626454380380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n using MCMCDiagnosticTools\n using LoopVectorization\n using Tullio\n \n-export relative_eff, psis_ess\n+export relative_eff, psis_ess, psis_n_eff\n \n \"\"\"\n     relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=FFTESSMethod())\n \n"
                },
                {
                    "date": 1626454430031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,13 +51,13 @@\n     @tullio sum_of_squares[x] := weights[x, y]^2\n     return @tturbo r_eff ./ sum_of_squares\n end\n \n-function psis_ess(weights::AbstractArray{T}) where {T<:AbstractFloat}\n+function psis_ess(weights::AbstractMatrix{T}) where {T<:AbstractFloat}\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n \n-function psis_n_eff(args...) \n-    psis_ess\n+function psis_n_eff(args...; kwargs...) \n+    return psis_ess(args...; kwargs...)\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626454496697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,7 +57,7 @@\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n \n-function psis_n_eff(args...; kwargs...) \n+function psis_n_eff(args...; kwargs...)  # Alias for compatibility with R version\n     return psis_ess(args...; kwargs...)\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626454514402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n using MCMCDiagnosticTools\n using LoopVectorization\n using Tullio\n \n-export relative_eff, psis_ess, psis_n_eff\n+export relative_eff, psis_ess\n \n \"\"\"\n     relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=FFTESSMethod())\n \n@@ -56,8 +56,4 @@\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n-\n-function psis_n_eff(args...; kwargs...)  # Alias for compatibility with R version\n-    return psis_ess(args...; kwargs...)\n-end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626454525488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n using MCMCDiagnosticTools\n using LoopVectorization\n using Tullio\n \n-export relative_eff, psis_ess\n+export relative_eff, psis_ess, psis_n_eff\n \n \"\"\"\n     relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=FFTESSMethod())\n \n@@ -56,4 +56,8 @@\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n+\n+function psis_n_eff(args...; kwargs...)  # Alias for compatibility with R version\n+    return psis_ess(args...; kwargs...)\n+end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626484291838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,10 +11,10 @@\n Calculate the relative efficiency of an MCMC chain, i.e. the effective sample size divided\n by the nominal sample size.\n \"\"\"\n function relative_eff(\n-    sample::AbstractArray{T,3}; method=FFTESSMethod()\n-) where {T<:AbstractFloat}\n+    sample::AbstractArray{T, 3}; method=FFTESSMethod()\n+) where {T <: AbstractFloat}\n     dims = size(sample)\n     post_sample_size = dims[2] * dims[3]\n     # Only need ESS, not rhat\n     ess_sample = inv.(permutedims(sample, [2, 1, 3]))\n@@ -33,27 +33,27 @@\n Vehtari et al. 2019.\n \n # Arguments\n \n-- `weights`: A set of importance sampling weights derived from PSIS.\n-- `r_eff`: The relative efficiency of the MCMC chains from which PSIS samples were derived.\n-See `?relative_eff` to calculate `r_eff`.\n+  - `weights`: A set of importance sampling weights derived from PSIS.\n+  - `r_eff`: The relative efficiency of the MCMC chains from which PSIS samples were derived.\n+    See `?relative_eff` to calculate `r_eff`.\n \"\"\"\n function psis_ess(\n     weights::AbstractVector{T}, r_eff::AbstractVector{T}\n-) where {T<:AbstractFloat}\n+) where {T <: AbstractFloat}\n     @tullio sum_of_squares := weights[x]^2\n     return r_eff ./ sum_of_squares\n end\n \n function psis_ess(\n     weights::AbstractMatrix{T}, r_eff::AbstractVector{T}\n-) where {T<:AbstractFloat}\n+) where {T <: AbstractFloat}\n     @tullio sum_of_squares[x] := weights[x, y]^2\n     return @tturbo r_eff ./ sum_of_squares\n end\n \n-function psis_ess(weights::AbstractMatrix{T}) where {T<:AbstractFloat}\n+function psis_ess(weights::AbstractMatrix{T}) where {T <: AbstractFloat}\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n"
                },
                {
                    "date": 1626559398952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,16 +5,16 @@\n \n export relative_eff, psis_ess, psis_n_eff\n \n \"\"\"\n-    relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=FFTESSMethod())\n+    relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=MCMCDiagnosticTools.FFTESSMethod())\n \n Calculate the relative efficiency of an MCMC chain, i.e. the effective sample size divided\n by the nominal sample size.\n \"\"\"\n function relative_eff(\n-    sample::AbstractArray{T, 3}; method=FFTESSMethod()\n-) where {T <: AbstractFloat}\n+    sample::AbstractArray{T,3}; method=MCMCDiagnosticTools.FFTESSMethod()\n+) where {T<:AbstractFloat}\n     dims = size(sample)\n     post_sample_size = dims[2] * dims[3]\n     # Only need ESS, not rhat\n     ess_sample = inv.(permutedims(sample, [2, 1, 3]))\n@@ -36,8 +36,11 @@\n \n   - `weights`: A set of importance sampling weights derived from PSIS.\n   - `r_eff`: The relative efficiency of the MCMC chains from which PSIS samples were derived.\n     See `?relative_eff` to calculate `r_eff`.\n+\n+# Returns\n+\n \"\"\"\n function psis_ess(\n     weights::AbstractVector{T}, r_eff::AbstractVector{T}\n ) where {T <: AbstractFloat}\n"
                },
                {
                    "date": 1626559414548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,8 +39,9 @@\n     See `?relative_eff` to calculate `r_eff`.\n \n # Returns\n \n+\n \"\"\"\n function psis_ess(\n     weights::AbstractVector{T}, r_eff::AbstractVector{T}\n ) where {T <: AbstractFloat}\n"
                },
                {
                    "date": 1626559453220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,12 +36,8 @@\n \n   - `weights`: A set of importance sampling weights derived from PSIS.\n   - `r_eff`: The relative efficiency of the MCMC chains from which PSIS samples were derived.\n     See `?relative_eff` to calculate `r_eff`.\n-\n-# Returns\n-\n-\n \"\"\"\n function psis_ess(\n     weights::AbstractVector{T}, r_eff::AbstractVector{T}\n ) where {T <: AbstractFloat}\n"
                },
                {
                    "date": 1626565236501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,9 @@\n     r_eff = ess / post_sample_size\n     return r_eff\n end\n \n+\n \"\"\"\n     function psis_ess(\n         weights::AbstractVector{T},\n         r_eff::AbstractVector{T}\n@@ -44,20 +45,23 @@\n     @tullio sum_of_squares := weights[x]^2\n     return r_eff ./ sum_of_squares\n end\n \n+\n function psis_ess(\n     weights::AbstractMatrix{T}, r_eff::AbstractVector{T}\n ) where {T <: AbstractFloat}\n     @tullio sum_of_squares[x] := weights[x, y]^2\n     return @tturbo r_eff ./ sum_of_squares\n end\n \n+\n function psis_ess(weights::AbstractMatrix{T}) where {T <: AbstractFloat}\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n \n+\n function psis_n_eff(args...; kwargs...)  # Alias for compatibility with R version\n     return psis_ess(args...; kwargs...)\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626650524434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,19 +5,20 @@\n \n export relative_eff, psis_ess, psis_n_eff\n \n \"\"\"\n-    relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=MCMCDiagnosticTools.FFTESSMethod())\n+    relative_eff(sample::AbstractArray{AbstractFloat, 3}; \n+        method=MCMCDiagnosticTools.FFTESSMethod()\n+    )\n \n Calculate the relative efficiency of an MCMC chain, i.e. the effective sample size divided\n by the nominal sample size.\n \"\"\"\n function relative_eff(\n     sample::AbstractArray{T,3}; method=MCMCDiagnosticTools.FFTESSMethod()\n-) where {T<:AbstractFloat}\n+) where {T<:Union{AbstractFloat, Missing}}\n     dims = size(sample)\n     post_sample_size = dims[2] * dims[3]\n-    # Only need ESS, not rhat\n     ess_sample = inv.(permutedims(sample, [2, 1, 3]))\n     ess, = MCMCDiagnosticTools.ess_rhat(ess_sample; method=method, maxlag=dims[2])\n     r_eff = ess / post_sample_size\n     return r_eff\n@@ -40,23 +41,23 @@\n     See `?relative_eff` to calculate `r_eff`.\n \"\"\"\n function psis_ess(\n     weights::AbstractVector{T}, r_eff::AbstractVector{T}\n-) where {T <: AbstractFloat}\n+) where {T <: Union{AbstractFloat, Missing}}\n     @tullio sum_of_squares := weights[x]^2\n     return r_eff ./ sum_of_squares\n end\n \n \n function psis_ess(\n     weights::AbstractMatrix{T}, r_eff::AbstractVector{T}\n-) where {T <: AbstractFloat}\n+) where {T <: Union{AbstractFloat, Missing}}\n     @tullio sum_of_squares[x] := weights[x, y]^2\n     return @tturbo r_eff ./ sum_of_squares\n end\n \n \n-function psis_ess(weights::AbstractMatrix{T}) where {T <: AbstractFloat}\n+function psis_ess(weights::AbstractMatrix{T}) where {T <: Union{AbstractFloat, Missing}}\n     @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n           \"will be overoptimistic if samples are autocorrelated.\"\n     return psis_ess(weights, ones(size(weights)))\n end\n"
                }
            ],
            "date": 1626309971342,
            "name": "Commit-0",
            "content": "using FFTW\nusing MCMCDiagnosticTools\nusing LoopVectorization\nusing TensorOperations\nusing Tullio\n\nexport relative_eff, psis_n_eff\n\n\"\"\"\n    relative_eff(sample::AbstractArray{AbstractFloat, 3}; method=FFTESSMethod())\n\nCompute the MCMC effective sample size divided by the nominal sample size.\n\"\"\"\nfunction relative_eff(\n    sample::AbstractArray{T,3}; method=FFTESSMethod()\n) where {T<:AbstractFloat}\n    dims = size(sample)\n    post_sample_size = dims[2] * dims[3]\n    # Only need ESS, not rhat\n    ess_sample = inv.(permutedims(sample, [2, 1, 3]))\n    ess, = MCMCDiagnosticTools.ess_rhat(ess_sample; method=method, maxlag=dims[2])\n    r_eff = ess / post_sample_size\n    return r_eff\nend\n\n\"\"\"\n    function psis_n_eff(\n        weights::AbstractVector{T},\n        r_eff::AbstractVector{T}\n    ) -> AbstractVector{T}\n\"\"\"\nfunction psis_n_eff(\n    weights::AbstractVector{T}, r_eff::AbstractVector{T}\n) where {T<:AbstractFloat}\n    @tullio sum_of_squares := weights[x]^2\n    return r_eff ./ sum_of_squares\nend\n\nfunction psis_n_eff(\n    weights::AbstractMatrix{T}, r_eff::AbstractVector{T}\n) where {T<:AbstractFloat}\n    @tullio sum_of_squares[x] := weights[x, y]^2\n    return @turbo r_eff ./ sum_of_squares\nend\n\nfunction psis_n_eff(weights::AbstractArray{T}) where {T<:AbstractFloat}\n    @warn \"PSIS ESS not adjusted based on MCMC ESS. MCSE and ESS estimates \" *\n          \"will be overoptimistic if samples are autocorrelated.\"\n    return psis_n_eff(weights, ones(size(weights)))\nend\n"
        }
    ]
}