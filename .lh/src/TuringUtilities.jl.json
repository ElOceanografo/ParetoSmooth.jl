{
    "sourceFile": "src/TuringUtilities.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1626559320631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626561337701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,19 +3,22 @@\n \n \"\"\"\n     pointwise_log_likelihoods(chain::Chains, model)\n \n-Computes the pointwise log likelihoods from Turing model where [d,s,c] corresponds to \n-log likelihood of evaluated at datapoint d, sample s, for chain c. Note that\n-currently the posterior log likelihood must be computed in a for loop in the \n-Turing model.\n+Compute the pointwise log-likelihoods from a Turing model. \n \n+\n+**Important Note:** The posterior log-likelihood must be computed in a for loop in the \n+Turing model; broadcasting will result in all observations being treated as coming from a\n+single point.\n+\n # Arguments\n-- `chain::Chains`: a chain object from MCMCChains from a Turing model\n-- `model`: a Turing model with data in the form of model(data)\n+- `chain::Chains`: A chain object from MCMCChains.\n+- `model`: A Turing model with data in the form of `model(data)`.\n \n # Returns\n-- `Array{3}`: a three dimensional array of pointwise log likelihoods\n+- `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n+indexed using `array[data, sample, chain]`.\n \n \"\"\"\n function pointwise_log_likelihoods(chain::Chains, model)\n     # subset of chain for mcmc samples\n"
                },
                {
                    "date": 1626561386108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,12 +5,11 @@\n     pointwise_log_likelihoods(chain::Chains, model)\n \n Compute the pointwise log-likelihoods from a Turing model. \n \n-\n **Important Note:** The posterior log-likelihood must be computed in a for loop in the \n-Turing model; broadcasting will result in all observations being treated as coming from a\n-single point.\n+Turing model; broadcasting will result in all observations being treated as cpnsisting of a\n+single point. \n \n # Arguments\n - `chain::Chains`: A chain object from MCMCChains.\n - `model`: A Turing model with data in the form of `model(data)`.\n"
                },
                {
                    "date": 1626561436023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n     # Convert from dictionary to 3d array\n     return permutedims(cat((pointwise_log_like_dict[k] for k in sorted_keys)...; dims=3), (3, 1, 2))\n end\n \n+\n \"\"\"\n     function psis_loo(ll_fun::Function, chain::Chains, data, args...;\n         source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n     ) -> PsisLoo\n@@ -46,11 +47,11 @@\n \n   - `chain::Chains`: a chain object from MCMCChains from a Turing model\n   - `model`: a Turing model with data in the form of model(data)\n   - `args...`: Positional arguments to be passed to [`psis`](@ref).\n-  - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n-    instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]`\n-    belongs to the second chain.\n+  - `chain_index::Vector`: A vector of integers specifying which chain each iteration \n+    belongs to. For instance, `chain_index[iteration]` should return `2` if\n+    `log_likelihood[:, step]` belongs to the second chain.\n   - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n"
                },
                {
                    "date": 1626561617532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,19 @@\n using .Turing, .MCMCChains\n export pointwise_log_likelihoods\n \n+const TURING_LOOP_WARN = \"\"\"\n+**Important Note:** The posterior log-likelihood must be computed with a `for` loop inside a \n+Turing model; broadcasting will result in all observations being treated as if they are a\n+single point. \n \"\"\"\n+\n+\"\"\"\n     pointwise_log_likelihoods(chain::Chains, model)\n \n Compute the pointwise log-likelihoods from a Turing model. \n \n-**Important Note:** The posterior log-likelihood must be computed in a for loop in the \n-Turing model; broadcasting will result in all observations being treated as cpnsisting of a\n-single point. \n+$TURING_LOOP_WARN\n \n # Arguments\n - `chain::Chains`: A chain object from MCMCChains.\n - `model`: A Turing model with data in the form of `model(data)`.\n@@ -38,12 +42,12 @@\n         source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n     ) -> PsisLoo\n \n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n-score based on MCMCChain object and Turing model. Note that the Turing model must compute \n-the log likelihood in a loop over the data rather than using broadcasting. Otherwise the \n-correct pointwise log likehoods will not be used.\n+score based on MCMCChain object and Turing model. \n \n+$TURING_LOOP_WARN\n+\n # Arguments\n \n   - `chain::Chains`: a chain object from MCMCChains from a Turing model\n   - `model`: a Turing model with data in the form of model(data)\n@@ -61,8 +65,10 @@\n     )\n     pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n     return psis_loo(pointwise_log_likes, args...; source, log_weights, kwargs...)\n end\n+\n+\n \"\"\"\n     psis(\n         ll_fun::Function, \n         chain::Chains,\n@@ -70,10 +76,12 @@\n         source::String=\"mcmc\", \n         log_weights::Bool=false\n     ) -> Psis\n \n-Implements Pareto-smoothed importance sampling (PSIS) based on MCMCChain object and Turing model.\n-Note that the Turing model must compute the log likelihood in a loop over the data rather than \n+Implements Pareto-smoothed importance sampling (PSIS) based on MCMCChain object and \n+Turing model.\n+\n+Note that the Turing model must compute the log likelihood with a `for` loop over the data, rather than \n using broadcasting. Otherwise the correct pointwise log likehoods will not be used.\n \n # Arguments\n ## Positional Arguments\n"
                },
                {
                    "date": 1626561700776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,13 +76,11 @@\n         source::String=\"mcmc\", \n         log_weights::Bool=false\n     ) -> Psis\n \n-Implements Pareto-smoothed importance sampling (PSIS) based on MCMCChain object and \n-Turing model.\n+Generate samples using Pareto smoothed importance sampling (PSIS).\n \n-Note that the Turing model must compute the log likelihood with a `for` loop over the data, rather than \n-using broadcasting. Otherwise the correct pointwise log likehoods will not be used.\n+$TURING_LOOP_WARN\n \n # Arguments\n ## Positional Arguments\n - `chain::Chains`: a chain object from MCMCChains from a Turing model\n"
                },
                {
                    "date": 1626563981438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,20 +97,8 @@\n used. If `\"mcmc\"`, adjusts ESS for autocorrelation. Otherwise, samples are assumed to be \n independent. Currently permitted values are $SAMPLE_SOURCES.\n - `log_weights::Bool=false`: Return log weights, rather than the PSIS weights. \n \"\"\"\n-function psis(\n-    model, chain::Chains, r_eff;\n-    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false\n-    )\n+function psis(model, chain::Chains, args...; kwargs...)\n     pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n-    return psis(-pointwise_log_likes, r_eff; source, log_weights)\n+    return psis(-pointwise_log_likes, args...; kwargs...)\n end\n-\n-function psis(\n-    model, chain::Chains;\n-    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false\n-    )\n-    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n-    r_eff = similar(pointwise_log_likes, 0)\n\\ No newline at end of file\n-    return psis(-pointwise_log_likes, r_eff; source, log_weights)\n-end\n"
                },
                {
                    "date": 1626564717880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    return permutedims(cat((pointwise_log_like_dict[k] for k in sorted_keys)...; dims=3), (3, 1, 2))\n+    return cat((pointwise_log_like_dict[k] for k in sorted_keys)...; dims=3)\n end\n \n \n \"\"\"\n"
                }
            ],
            "date": 1626559320631,
            "name": "Commit-0",
            "content": "using .Turing, .MCMCChains\nexport pointwise_log_likelihoods\n\n\"\"\"\n    pointwise_log_likelihoods(chain::Chains, model)\n\nComputes the pointwise log likelihoods from Turing model where [d,s,c] corresponds to \nlog likelihood of evaluated at datapoint d, sample s, for chain c. Note that\ncurrently the posterior log likelihood must be computed in a for loop in the \nTuring model.\n\n# Arguments\n- `chain::Chains`: a chain object from MCMCChains from a Turing model\n- `model`: a Turing model with data in the form of model(data)\n\n# Returns\n- `Array{3}`: a three dimensional array of pointwise log likelihoods\n\n\"\"\"\nfunction pointwise_log_likelihoods(chain::Chains, model)\n    # subset of chain for mcmc samples\n    chain_params = MCMCChains.get_sections(chain, :parameters)\n    # compute the pointwise log likelihoods\n    pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n    # parse \"var[i]\" -> i\n    ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n    # collect variable names\n    sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n    # Convert from dictionary to 3d array\n    return permutedims(cat((pointwise_log_like_dict[k] for k in sorted_keys)...; dims=3), (3, 1, 2))\nend\n\n\"\"\"\n    function psis_loo(ll_fun::Function, chain::Chains, data, args...;\n        source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n    ) -> PsisLoo\n\nUse Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\nscore based on MCMCChain object and Turing model. Note that the Turing model must compute \nthe log likelihood in a loop over the data rather than using broadcasting. Otherwise the \ncorrect pointwise log likehoods will not be used.\n\n# Arguments\n\n  - `chain::Chains`: a chain object from MCMCChains from a Turing model\n  - `model`: a Turing model with data in the form of model(data)\n  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n  - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n    instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]`\n    belongs to the second chain.\n  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n\nSee also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n\"\"\"\nfunction psis_loo(\n    model, chain::Chains, args...;\n    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false, kwargs...\n    )\n    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n    return psis_loo(pointwise_log_likes, args...; source, log_weights, kwargs...)\nend\n\"\"\"\n    psis(\n        ll_fun::Function, \n        chain::Chains,\n        data; \n        source::String=\"mcmc\", \n        log_weights::Bool=false\n    ) -> Psis\n\nImplements Pareto-smoothed importance sampling (PSIS) based on MCMCChain object and Turing model.\nNote that the Turing model must compute the log likelihood in a loop over the data rather than \nusing broadcasting. Otherwise the correct pointwise log likehoods will not be used.\n\n# Arguments\n## Positional Arguments\n- `chain::Chains`: a chain object from MCMCChains from a Turing model\n- `model`: a Turing model with data in the form of model(data)\n- `r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \nin ESS calculations. If left empty, calculated automatically using the FFTESS method \nfrom InferenceDiagnostics.jl. See `relative_eff` to calculate these values. \n\n## Keyword Arguments\n\n- `chain_index::Vector{Integer}`: An (optional) vector of integers indicating which chain \neach sample belongs to.\n- `source::String=\"mcmc\"`: A string or symbol describing the source of the sample being \nused. If `\"mcmc\"`, adjusts ESS for autocorrelation. Otherwise, samples are assumed to be \nindependent. Currently permitted values are $SAMPLE_SOURCES.\n- `log_weights::Bool=false`: Return log weights, rather than the PSIS weights. \n\"\"\"\nfunction psis(\n    model, chain::Chains, r_eff;\n    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false\n    )\n    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n    return psis(-pointwise_log_likes, r_eff; source, log_weights)\nend\n\nfunction psis(\n    model, chain::Chains;\n    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false\n    )\n    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n    r_eff = similar(pointwise_log_likes, 0)\n    return psis(-pointwise_log_likes, r_eff; source, log_weights)\nend"
        }
    ]
}