{
    "sourceFile": "src/MCMCChainsUtilities.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1626559337463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1626559337463,
            "name": "Commit-0",
            "content": "using .MCMCChains\nexport pointwise_log_likelihoods\n\n\"\"\"\n    pointwise_log_likelihoods(ll_fun::Function, chain::Chains, data)\n\nComputes the pointwise log likelihoods where [d,s,c] corresponds to log likelihood of \nevaluated at datapoint d, sample s, for chain c. \n\n# Arguments\n- `ll_fun::Function`: a function that computes the log likelihood of a single data point: \n    f(θ1, ..., θn, data), where θi is the ith parameter\n- `chain::Chain`: a chain object from MCMCChains\n- `data`: a vector of data used to estimate parameters of the model\n\n# Returns\n- `Array{Float64,3}`: a three dimensional array of pointwise log likelihoods \n\"\"\"\nfunction pointwise_log_likelihoods(ll_fun::Function, chain::Chains, data)\n    samples = Array(Chains(chain, :parameters).value)\n    pointwise_log_likelihoods(ll_fun, samples, data)\nend\n\n\"\"\"\n    function psis_loo(ll_fun::Function, chain::Chains, data, args...;\n        source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n    ) -> PsisLoo\n\nUse Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\nscore based on MCMCChain.\n\n# Arguments\n\n  - `ll_fun::Function`: a function that computes the log likelihood of a single data point: \n    f(θ1, ..., θn, data), where θi is the ith parameter\n  - `chain::Chain`: a chain object from MCMCChains\n  - `data`: a vector of data used to estimate parameters of the model\n  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n  - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n    instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]`\n    belongs to the second chain.\n  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n\nSee also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n\"\"\"\nfunction psis_loo(\n    ll_fun::Function, chain::Chains, data, args...;\n    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false, kwargs...\n    )\n    pointwise_log_likes = pointwise_log_likelihoods(ll_fun, chain, data)\n    return psis_loo(pointwise_log_likes, args...; source, log_weights, kwargs...)\nend\n\n\"\"\"\n    psis(\n        ll_fun::Function, \n        chain::Chains,\n        data; \n        source::String=\"mcmc\", \n        log_weights::Bool=false\n    ) -> Psis\n\nImplements Pareto-smoothed importance sampling (PSIS) based on MCMCChain object.\n\n# Arguments\n## Positional Arguments\n- `ll_fun::Function`: a function that computes the log likelihood of a single data point: \nf(θ1, ..., θn, data), where θi is the ith parameter\n- `chain::Chain`: a chain object from MCMCChains\n- `data`: a vector of data used to estimate parameters of the model\n- `r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \nin ESS calculations. If left empty, calculated automatically using the FFTESS method \nfrom InferenceDiagnostics.jl. See `relative_eff` to calculate these values. \n\n## Keyword Arguments\n\n- `chain_index::Vector{Integer}`: An (optional) vector of integers indicating which chain \neach sample belongs to.\n- `source::String=\"mcmc\"`: A string or symbol describing the source of the sample being \nused. If `\"mcmc\"`, adjusts ESS for autocorrelation. Otherwise, samples are assumed to be \nindependent. Currently permitted values are $SAMPLE_SOURCES.\n- `log_weights::Bool=false`: Return log weights, rather than the PSIS weights. \n\"\"\"\nfunction psis(\n    ll_fun::Function, chain::Chains, data, r_eff;\n    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false\n    )\n    pointwise_log_likes = pointwise_log_likelihoods(ll_fun, chain, data)\n    return psis(-pointwise_log_likes, r_eff; source, log_weights)\nend\n\nfunction psis(\n    ll_fun::Function, chain::Chains, data;\n    source::Union{AbstractString,Symbol}=\"mcmc\", log_weights::Bool=false\n    )\n    pointwise_log_likes = pointwise_log_likelihoods(ll_fun, chain, data)\n    r_eff = similar(pointwise_log_likes, 0)\n    return psis(-pointwise_log_likes, r_eff; source, log_weights)\nend\n"
        }
    ]
}