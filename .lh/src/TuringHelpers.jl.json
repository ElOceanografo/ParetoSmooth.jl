{
    "sourceFile": "src/TuringHelpers.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 29,
            "patches": [
                {
                    "date": 1626565365953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626565414955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,14 +14,14 @@\n \n $TURING_LOOP_WARN\n \n # Arguments\n-- `chain::Chains`: A chain object from MCMCChains.\n-- `model`: A Turing model with data in the form of `model(data)`.\n+  - `chain::Chains`: A chain object from MCMCChains.\n+  - `model`: A Turing model with data in the form of `model(data)`.\n \n # Returns\n-- `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n-indexed using `array[data, sample, chain]`.\n+  - `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n+    indexed using `array[data, sample, chain]`.\n \n \"\"\"\n function pointwise_log_likelihoods(chain::Chains, model)\n     # subset of chain for mcmc samples\n"
                },
                {
                    "date": 1626565734907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,7 +95,7 @@\n independent. Currently permitted values are $SAMPLE_SOURCES.\n - `log_weights::Bool=false`: Return log weights, rather than the PSIS weights. \n \"\"\"\n function psis(model, chain::Chains, args...; kwargs...)\n-    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n-    return psis(-pointwise_log_likes, args...; kwargs...)\n+    log_ratios = pointwise_log_likelihoods(chain, model)\n+    return psis(-log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626565766883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,8 +59,9 @@\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function psis_loo(model, chain::Chains, args...; kwargs...)\n+    @info TURING_LOOP_WARN\n     pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n     return psis_loo(pointwise_log_likes, args...; kwargs...)\n end\n \n"
                },
                {
                    "date": 1626571100317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,10 @@\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    return cat((pointwise_log_like_dict[k] for k in sorted_keys)...; dims=3)\n+    array = reduce(vcat, [pointwise_log_like_dict[k] for k in sorted_keys])\n+    return array\n end\n \n \n \"\"\"\n"
                },
                {
                    "date": 1626575950253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,30 +1,33 @@\n+using Tables\n using .Turing, .MCMCChains\n export pointwise_log_likelihoods\n \n const TURING_LOOP_WARN = \"\"\"\n **Important Note:** The posterior log-likelihood must be computed with a `for` loop inside a \n Turing model; broadcasting will result in all observations being treated as if they are a\n single point. \n \"\"\"\n+const CHAINS = \"\"\"  - `chains`: A `Chains` object from MCMCChains.\"\"\"\n \n \"\"\"\n-    pointwise_log_likelihoods(chain::Chains, model)\n+    pointwise_log_likelihoods(model, chain::Chains)\n \n Compute the pointwise log-likelihoods from a Turing model. \n \n $TURING_LOOP_WARN\n \n # Arguments\n+  - `model`: A Turing model with data in the form of `model(data)`.\n   - `chain::Chains`: A chain object from MCMCChains.\n-  - `model`: A Turing model with data in the form of `model(data)`.\n+  \n \n # Returns\n   - `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n     indexed using `array[data, sample, chain]`.\n \n \"\"\"\n-function pointwise_log_likelihoods(chain::Chains, model)\n+function pointwise_log_likelihoods(model, chain::Chains)\n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n@@ -32,9 +35,13 @@\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    array = reduce(vcat, [pointwise_log_like_dict[k] for k in sorted_keys])\n+    array = Array(eltype())\n+    for slice in eachslice(array; dims=1)\n+        slice .= \n+    end\n+    \n     return array\n end\n \n \n@@ -52,18 +59,16 @@\n \n   - `chain::Chains`: A chain object from MCMCChains.\n   - `model`: A Turing model with data in the form of `model(data)`.\n   - `args...`: Positional arguments to be passed to [`psis`](@ref).\n-  - `chain_index::Vector`: An optional vector of integers specifying which chain each \n-    iteration belongs to. For instance, `chain_index[iteration]` should return `2` if\n-    `log_likelihood[:, step]` belongs to the second chain.\n+  - $CHAIN_INDEX_DOC\n   - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function psis_loo(model, chain::Chains, args...; kwargs...)\n     @info TURING_LOOP_WARN\n-    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n+    pointwise_log_likes = pointwise_log_likelihoods(model, chain, args...; kwargs...)\n     return psis_loo(pointwise_log_likes, args...; kwargs...)\n end\n \n \n"
                },
                {
                    "date": 1626622682754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,20 +6,26 @@\n **Important Note:** The posterior log-likelihood must be computed with a `for` loop inside a \n Turing model; broadcasting will result in all observations being treated as if they are a\n single point. \n \"\"\"\n-const CHAINS = \"\"\"  - `chains`: A `Chains` object from MCMCChains.\"\"\"\n+const CHAINS_ARG = \"\"\"\n+`chains::Chains`: A chain object from MCMCChains.\n+\"\"\"\n+const TURING_MODEL_ARG = \"\"\"\n+`model`: A Turing model with data in the form of `model(data)`.\n+\"\"\"\n \n+\n \"\"\"\n     pointwise_log_likelihoods(model, chain::Chains)\n \n Compute the pointwise log-likelihoods from a Turing model. \n \n $TURING_LOOP_WARN\n \n # Arguments\n-  - `model`: A Turing model with data in the form of `model(data)`.\n-  - `chain::Chains`: A chain object from MCMCChains.\n+  - $TURING_MODEL_ARG\n+  - $CHAINS_ARG\n   \n \n # Returns\n   - `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n@@ -35,19 +41,16 @@\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    array = Array(eltype())\n-    for slice in eachslice(array; dims=1)\n-        slice .= \n-    end\n+    array = similar()\n     \n     return array\n end\n \n \n \"\"\"\n-    function psis_loo(ll_fun::Function, chain::Chains, data, args...;\n+    function psis_loo(ll_fun::Function, chains::Chains, data, args...;\n         source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n     ) -> PsisLoo\n \n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n@@ -56,11 +59,11 @@\n $TURING_LOOP_WARN\n \n # Arguments\n \n-  - `chain::Chains`: A chain object from MCMCChains.\n-  - `model`: A Turing model with data in the form of `model(data)`.\n-  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n+  - $CHAINS_ARG\n+  - $TURING_MODEL_ARG\n+  -  [`psis`](@ref).\n   - $CHAIN_INDEX_DOC\n   - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n@@ -74,34 +77,22 @@\n \n \"\"\"\n     psis(\n         ll_fun::Function, \n-        chain::Chains,\n-        data; \n-        source::String=\"mcmc\", \n-        log_weights::Bool=false\n+        chains::Chains,\n+        args...; \n+        kwargs...\n     ) -> Psis\n \n Generate samples using Pareto smoothed importance sampling (PSIS).\n \n $TURING_LOOP_WARN\n \n # Arguments\n-## Positional Arguments\n-- `chain::Chains`: a chain object from MCMCChains from a Turing model\n-- `model`: a Turing model with data in the form of model(data)\n-- `r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \n-in ESS calculations. If left empty, calculated automatically using the FFTESS method \n-from InferenceDiagnostics.jl. See `relative_eff` to calculate these values. \n-\n-## Keyword Arguments\n-\n-- `chain_index::Vector{Integer}`: An (optional) vector of integers indicating which chain \n-each sample belongs to.\n-- `source::String=\"mcmc\"`: A string or symbol describing the source of the sample being \n-used. If `\"mcmc\"`, adjusts ESS for autocorrelation. Otherwise, samples are assumed to be \n-independent. Currently permitted values are $SAMPLE_SOURCES.\n-- `log_weights::Bool=false`: Return log weights, rather than the PSIS weights. \n+  - $CHAINS_ARG\n+  - $TURING_MODEL_ARG\n+  - $ARGS\n+  - $KWARGS\n \"\"\"\n function psis(model, chain::Chains, args...; kwargs...)\n     log_ratios = pointwise_log_likelihoods(chain, model)\n     return psis(-log_ratios, args...; kwargs...)\n"
                },
                {
                    "date": 1626623488080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,28 +24,37 @@\n \n # Arguments\n   - $TURING_MODEL_ARG\n   - $CHAINS_ARG\n-  \n \n # Returns\n   - `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n     indexed using `array[data, sample, chain]`.\n-\n \"\"\"\n function pointwise_log_likelihoods(model, chain::Chains)\n+\n+    @info TURING_LOOP_WARN\n+\n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n+\n+    # make sure all Turing chains are of equal length\n+    dims = size(first(pointwise_log_like_dict))\n+    if any(dims .≠ size.(pointwise_log_like_dict))\n+        throw(ArgumentError(\"Not all chains are of the same length.\"))\n+    end\n+\n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    array = similar()\n-    \n-    return array\n+    n_params = length(sorted_keys)\n+    array = [pointwise_log_likelihoods[i] for i in sorted_keys]\n+    array = reshape(array, 1, n_params, dims...)\n+    return reduce(vcat, array)\n end\n \n \n \"\"\"\n@@ -61,11 +70,11 @@\n # Arguments\n \n   - $CHAINS_ARG\n   - $TURING_MODEL_ARG\n-  -  [`psis`](@ref).\n+  - $ARGS [`psis`](@ref).\n   - $CHAIN_INDEX_DOC\n-  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n+  - $KWARGS [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function psis_loo(model, chain::Chains, args...; kwargs...)\n@@ -89,11 +98,12 @@\n \n # Arguments\n   - $CHAINS_ARG\n   - $TURING_MODEL_ARG\n-  - $ARGS\n-  - $KWARGS\n+  - $ARGS [`psis`](@ref).\n+  - $KWARGS [`psis`](@ref).\n \"\"\"\n function psis(model, chain::Chains, args...; kwargs...)\n+    @info TURING_LOOP_WARN\n     log_ratios = pointwise_log_likelihoods(chain, model)\n     return psis(-log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626623967312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n \n     # make sure all Turing chains are of equal length\n-    dims = size(first(pointwise_log_like_dict))\n+    dims = size(first(values(pointwise_log_like_dict)))\n     if any(dims .≠ size.(pointwise_log_like_dict))\n         throw(ArgumentError(\"Not all chains are of the same length.\"))\n     end\n \n"
                },
                {
                    "date": 1626625387092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,9 +40,9 @@\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n \n     # make sure all Turing chains are of equal length\n     dims = size(first(values(pointwise_log_like_dict)))\n-    if any(dims .≠ size.(pointwise_log_like_dict))\n+    if any(dims .≠ size.(values(pointwise_log_like_dict)))\n         throw(ArgumentError(\"Not all chains are of the same length.\"))\n     end\n \n     # parse \"var[i]\" -> i\n"
                },
                {
                    "date": 1626625614398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,15 +37,9 @@\n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n-\n-    # make sure all Turing chains are of equal length\n     dims = size(first(values(pointwise_log_like_dict)))\n-    if any(dims .≠ size.(values(pointwise_log_like_dict)))\n-        throw(ArgumentError(\"Not all chains are of the same length.\"))\n-    end\n-\n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n"
                },
                {
                    "date": 1626625659482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n-    dims = size(first(values(pointwise_log_like_dict)))\n+    dims = size(values(first(pointwise_log_like_dict)))\n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n"
                },
                {
                    "date": 1626625962615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n-    dims = size(values(first(pointwise_log_like_dict)))\n+    dims = size(first(first(pointwise_log_like_dict)))  # Size of array (using )\n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n"
                },
                {
                    "date": 1626626002835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,10 @@\n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n-    dims = size(first(first(pointwise_log_like_dict)))  # Size of array (using )\n+    # Size of array (n_steps, n_chains) using first parameter\n+    dims = size(first(first(pointwise_log_like_dict)))  \n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n"
                },
                {
                    "date": 1626626137125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n     pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n     # Size of array (n_steps, n_chains) using first parameter\n-    dims = size(first(first(pointwise_log_like_dict)))  \n+    dims = size(last(first(pointwise_log_like_dict)))  \n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n"
                },
                {
                    "date": 1626626352739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,18 +36,18 @@\n \n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n-    pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n+    log_like_dict = pointwise_loglikelihoods(model, chain_params)\n     # Size of array (n_steps, n_chains) using first parameter\n-    dims = size(last(first(pointwise_log_like_dict)))  \n+    dims = size(last(first(log_like_dict)))  \n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n-    sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n+    sorted_keys = sort(collect(keys(log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n     n_params = length(sorted_keys)\n-    array = [pointwise_log_likelihoods[i] for i in sorted_keys]\n+    array = [log_like_dict[i] for i in sorted_keys]\n     array = reshape(array, 1, n_params, dims...)\n     return reduce(vcat, array)\n end\n \n"
                },
                {
                    "date": 1626626441303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,11 +44,10 @@\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    n_params = length(sorted_keys)\n     array = [log_like_dict[i] for i in sorted_keys]\n-    array = reshape(array, 1, n_params, dims...)\n+    array = reshape(array, 1, dims...)\n     return reduce(vcat, array)\n end\n \n \n"
                },
                {
                    "date": 1626626972903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n     # collect variable names\n     sorted_keys = sort(collect(keys(log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n     array = [log_like_dict[i] for i in sorted_keys]\n-    array = reshape(array, 1, dims...)\n+    array = reshape.(array, 1, dims...)\n     return reduce(vcat, array)\n end\n \n \n"
                },
                {
                    "date": 1626627074838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,9 @@\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n     # collect variable names\n     sorted_keys = sort(collect(keys(log_like_dict)); by=ind_from_string)\n     # Convert from dictionary to 3d array\n-    array = [log_like_dict[i] for i in sorted_keys]\n-    array = reshape.(array, 1, dims...)\n+    array = [reshape(log_like_dict[i], 1, dims...) for i in sorted_keys]\n     return reduce(vcat, array)\n end\n \n \n"
                },
                {
                    "date": 1626627327674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,7 +96,7 @@\n   - $KWARGS [`psis`](@ref).\n \"\"\"\n function psis(model, chain::Chains, args...; kwargs...)\n     @info TURING_LOOP_WARN\n-    log_ratios = pointwise_log_likelihoods(chain, model)\n+    log_ratios = pointwise_log_likelihoods(model, chain)\n     return psis(-log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626628343770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n # Returns\n   - `Array`: A three dimensional array of pointwise log likelihoods. This array should be\n     indexed using `array[data, sample, chain]`.\n \"\"\"\n-function pointwise_log_likelihoods(model, chain::Chains)\n+function pointwise_log_likelihoods(model::DynamicPPL.Model, chain::Chains)\n \n     @info TURING_LOOP_WARN\n \n     # subset of chain for mcmc samples\n@@ -69,9 +69,9 @@\n   - $KWARGS [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n-function psis_loo(model, chain::Chains, args...; kwargs...)\n+function psis_loo(model::DynamicPPL.Model, chain::Chains, args...; kwargs...)\n     @info TURING_LOOP_WARN\n     pointwise_log_likes = pointwise_log_likelihoods(model, chain, args...; kwargs...)\n     return psis_loo(pointwise_log_likes, args...; kwargs...)\n end\n@@ -89,14 +89,14 @@\n \n $TURING_LOOP_WARN\n \n # Arguments\n+  - $TURING_MODEL_ARG\n   - $CHAINS_ARG\n-  - $TURING_MODEL_ARG\n   - $ARGS [`psis`](@ref).\n   - $KWARGS [`psis`](@ref).\n \"\"\"\n-function psis(model, chain::Chains, args...; kwargs...)\n+function psis(model::DynamicPPL.Model, chain::Chains, args...; kwargs...)\n     @info TURING_LOOP_WARN\n     log_ratios = pointwise_log_likelihoods(model, chain)\n     return psis(-log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626628597294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,23 +50,25 @@\n end\n \n \n \"\"\"\n-    function psis_loo(ll_fun::Function, chains::Chains, data, args...;\n-        source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n+    function psis_loo(\n+        ll_fun::Function, \n+        chains::Chains, \n+        args...;\n+        kwargs...\n     ) -> PsisLoo\n \n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n-score based on MCMCChain object and Turing model. \n+score from an MCMCChain object and a Turing model. \n \n $TURING_LOOP_WARN\n \n # Arguments\n \n   - $CHAINS_ARG\n   - $TURING_MODEL_ARG\n   - $ARGS [`psis`](@ref).\n-  - $CHAIN_INDEX_DOC\n   - $KWARGS [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n@@ -78,9 +80,9 @@\n \n \n \"\"\"\n     psis(\n-        ll_fun::Function, \n+        model::DynamicPPL.Model, \n         chains::Chains,\n         args...; \n         kwargs...\n     ) -> Psis\n"
                },
                {
                    "date": 1626628654995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,13 +15,13 @@\n \"\"\"\n \n \n \"\"\"\n-    pointwise_log_likelihoods(model, chain::Chains)\n+    pointwise_log_likelihoods(model::DynamicPPL.Model, chain::Chains)\n \n Compute the pointwise log-likelihoods from a Turing model. \n \n-$TURING_LOOP_WARN\n+$TURING_LOOP_WARN \n \n # Arguments\n   - $TURING_MODEL_ARG\n   - $CHAINS_ARG\n"
                },
                {
                    "date": 1626628763971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n \n     # subset of chain for mcmc samples\n     chain_params = MCMCChains.get_sections(chain, :parameters)\n     # compute the pointwise log likelihoods\n-    log_like_dict = pointwise_loglikelihoods(model, chain_params)\n+    log_like_dict = DynamicPPL.pointwise_loglikelihoods(model, chain_params)\n     # Size of array (n_steps, n_chains) using first parameter\n     dims = size(last(first(log_like_dict)))  \n     # parse \"var[i]\" -> i\n     ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n"
                },
                {
                    "date": 1626628870269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n using .Turing, .MCMCChains\n export pointwise_log_likelihoods\n \n const TURING_LOOP_WARN = \"\"\"\n-**Important Note:** The posterior log-likelihood must be computed with a `for` loop inside a \n+**Important Note:** The posterior log-likelihood must be computed with a `for` loop inside a\n Turing model; broadcasting will result in all observations being treated as if they are a\n single point. \n \"\"\"\n const CHAINS_ARG = \"\"\"\n"
                },
                {
                    "date": 1626629781548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,11 +71,11 @@\n   - $KWARGS [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n-function psis_loo(model::DynamicPPL.Model, chain::Chains, args...; kwargs...)\n+function psis_loo(model::DynamicPPL.Model, chain::Chains, r_eff; kwargs...)\n     @info TURING_LOOP_WARN\n-    pointwise_log_likes = pointwise_log_likelihoods(model, chain, args...; kwargs...)\n+    pointwise_log_likes = pointwise_log_likelihoods(model, chain; kwargs...)\n     return psis_loo(pointwise_log_likes, args...; kwargs...)\n end\n \n \n"
                },
                {
                    "date": 1626629788018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,9 @@\n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function psis_loo(model::DynamicPPL.Model, chain::Chains, r_eff; kwargs...)\n     @info TURING_LOOP_WARN\n-    pointwise_log_likes = pointwise_log_likelihoods(model, chain; kwargs...)\n+    pointwise_log_likes = pointwise_log_likelihoods(model, chain)\n     return psis_loo(pointwise_log_likes, args...; kwargs...)\n end\n \n \n"
                },
                {
                    "date": 1626629833466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,8 +95,10 @@\n   - $TURING_MODEL_ARG\n   - $CHAINS_ARG\n   - $ARGS [`psis`](@ref).\n   - $KWARGS [`psis`](@ref).\n+\n+See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function psis(model::DynamicPPL.Model, chain::Chains, args...; kwargs...)\n     @info TURING_LOOP_WARN\n     log_ratios = pointwise_log_likelihoods(model, chain)\n"
                },
                {
                    "date": 1626629901530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n   - $KWARGS [`psis`](@ref).\n \n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n-function psis_loo(model::DynamicPPL.Model, chain::Chains, r_eff; kwargs...)\n+function psis_loo(model::DynamicPPL.Model, chain::Chains, args...; kwargs...)\n     @info TURING_LOOP_WARN\n     pointwise_log_likes = pointwise_log_likelihoods(model, chain)\n     return psis_loo(pointwise_log_likes, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626629940766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,11 +52,10 @@\n \n \"\"\"\n     function psis_loo(\n         ll_fun::Function, \n-        chains::Chains, \n-        args...;\n-        kwargs...\n+        chains::Chains\n+        [, args...; kwargs...]\n     ) -> PsisLoo\n \n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n score from an MCMCChain object and a Turing model. \n"
                }
            ],
            "date": 1626565365953,
            "name": "Commit-0",
            "content": "using .Turing, .MCMCChains\nexport pointwise_log_likelihoods\n\nconst TURING_LOOP_WARN = \"\"\"\n**Important Note:** The posterior log-likelihood must be computed with a `for` loop inside a \nTuring model; broadcasting will result in all observations being treated as if they are a\nsingle point. \n\"\"\"\n\n\"\"\"\n    pointwise_log_likelihoods(chain::Chains, model)\n\nCompute the pointwise log-likelihoods from a Turing model. \n\n$TURING_LOOP_WARN\n\n# Arguments\n- `chain::Chains`: A chain object from MCMCChains.\n- `model`: A Turing model with data in the form of `model(data)`.\n\n# Returns\n- `Array`: A three dimensional array of pointwise log likelihoods. This array should be\nindexed using `array[data, sample, chain]`.\n\n\"\"\"\nfunction pointwise_log_likelihoods(chain::Chains, model)\n    # subset of chain for mcmc samples\n    chain_params = MCMCChains.get_sections(chain, :parameters)\n    # compute the pointwise log likelihoods\n    pointwise_log_like_dict = pointwise_loglikelihoods(model, chain_params)\n    # parse \"var[i]\" -> i\n    ind_from_string(x) = parse(Int, split(split(x, \"[\")[2], \"]\")[1])\n    # collect variable names\n    sorted_keys = sort(collect(keys(pointwise_log_like_dict)); by=ind_from_string)\n    # Convert from dictionary to 3d array\n    return cat((pointwise_log_like_dict[k] for k in sorted_keys)...; dims=3)\nend\n\n\n\"\"\"\n    function psis_loo(ll_fun::Function, chain::Chains, data, args...;\n        source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n    ) -> PsisLoo\n\nUse Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\nscore based on MCMCChain object and Turing model. \n\n$TURING_LOOP_WARN\n\n# Arguments\n\n  - `chain::Chains`: A chain object from MCMCChains.\n  - `model`: A Turing model with data in the form of `model(data)`.\n  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n  - `chain_index::Vector`: An optional vector of integers specifying which chain each \n    iteration belongs to. For instance, `chain_index[iteration]` should return `2` if\n    `log_likelihood[:, step]` belongs to the second chain.\n  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n\nSee also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n\"\"\"\nfunction psis_loo(model, chain::Chains, args...; kwargs...)\n    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n    return psis_loo(pointwise_log_likes, args...; kwargs...)\nend\n\n\n\"\"\"\n    psis(\n        ll_fun::Function, \n        chain::Chains,\n        data; \n        source::String=\"mcmc\", \n        log_weights::Bool=false\n    ) -> Psis\n\nGenerate samples using Pareto smoothed importance sampling (PSIS).\n\n$TURING_LOOP_WARN\n\n# Arguments\n## Positional Arguments\n- `chain::Chains`: a chain object from MCMCChains from a Turing model\n- `model`: a Turing model with data in the form of model(data)\n- `r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \nin ESS calculations. If left empty, calculated automatically using the FFTESS method \nfrom InferenceDiagnostics.jl. See `relative_eff` to calculate these values. \n\n## Keyword Arguments\n\n- `chain_index::Vector{Integer}`: An (optional) vector of integers indicating which chain \neach sample belongs to.\n- `source::String=\"mcmc\"`: A string or symbol describing the source of the sample being \nused. If `\"mcmc\"`, adjusts ESS for autocorrelation. Otherwise, samples are assumed to be \nindependent. Currently permitted values are $SAMPLE_SOURCES.\n- `log_weights::Bool=false`: Return log weights, rather than the PSIS weights. \n\"\"\"\nfunction psis(model, chain::Chains, args...; kwargs...)\n    pointwise_log_likes = pointwise_log_likelihoods(chain, model)\n    return psis(-pointwise_log_likes, args...; kwargs...)\nend\n"
        }
    ]
}