{
    "sourceFile": "src/LeaveOneOut.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1626310486785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626314395084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n using AxisKeys\n using InteractiveUtils\n using LoopVectorization\n using Statistics\n+using TensorOperations\n using Tullio\n \n \n export loo, psis_loo\n"
                },
                {
                    "date": 1626314575968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n using AxisKeys\n using InteractiveUtils\n using LoopVectorization\n using Statistics\n-using TensorOperations\n using Tullio\n \n \n export loo, psis_loo\n"
                },
                {
                    "date": 1626477799668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,16 @@\n export loo, psis_loo\n \n const LOO_METHODS = subtypes(AbstractLooMethod)\n \n+\"\"\"\n+    function loo(args...; method=PsisLooMethod(), kwargs...) -> \n+\n+Compute the approximate leave-one-out cross-validation score using the specified method.\n+\n+Currently, this function only serves to call `psis_loo`, but this could change in the\n+future.\n+\"\"\"\n function loo(args...; method=PsisLooMethod(), kwargs...)\n     if typeof(method) ∈ LOO_METHODS\n         return psis_loo(args...; kwargs...)\n     else\n@@ -17,14 +25,28 @@\n     end\n end\n \n \n-function psis_loo(log_likelihood::T, \n-    r_eff=similar(log_likelihood, 0);\n-    source::Union{AbstractString,Symbol}=\"mcmc\", \n-    log_weights::Bool=false\n-) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n+\"\"\"\n+    function psis_loo(log_likelihood[, args...];\n+        chain_index=ones(size(log_likelihood))[, kwargs...]\n+    )\n \n+Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n+score.\n+\n+# Arguments\n+- `log_likelihood::AbstractArray`: An array or matrix of log-likelihood values indexed as \n+`[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if \n+all data points were drawn from a single chain.\n+- `args...`: Positional arguments to be passed to [`psis`](@ref).\n+- `chain_index`: A vector of integers specifying which chain each iteration belongs to. For\n+instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]` \n+belongs to the second chain.\n+- `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n+\"\"\"\n+function psis_loo(log_likelihood::T, args...; kwargs...) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n+\n     source = lowercase(string(source))\n     dims = size(log_likelihood)\n     data_size = dims[1]\n     mcmc_count = dims[2] * dims[3]  # total number of samples from posterior\n@@ -34,9 +56,9 @@\n     # TODO: Add a way of using score functions other than ELPD\n     # log_likelihood::ArrayType = similar(log_likelihood)\n     # log_likelihood .= score(log_likelihood)\n \n-    psis_object = psis(-log_likelihood, r_eff; source=source, log_weights=log_weights)\n+    psis_object = psis(-log_likelihood, args...; kwargs...)\n     weights = psis_object.weights\n     ξ = psis_object.pareto_k\n     r_eff = psis_object.r_eff\n \n@@ -81,12 +103,11 @@\n end\n \n \n function psis_loo(log_likelihood::T, \n-    r_eff=similar(log_likelihood, 0);\n-    chain_index=ones(size(log_likelihood, 1)),\n-    source::Union{AbstractString,Symbol}=\"mcmc\", \n-    log_weights::Bool=false\n+    args...;\n+    chain_index::AbstractVector=ones(size(log_likelihood, 1)),\n+    kwargs...\n ) where {F<:AbstractFloat,T<:AbstractMatrix{F}}\n     new_log_ratios = _convert_to_array(log_likelihood, chain_index)\n-    return psis_loo(new_log_ratios, r_eff; source, log_weights)\n+    return psis_loo(new_log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626478035366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,27 +27,30 @@\n \n \n \"\"\"\n     function psis_loo(log_likelihood[, args...];\n-        chain_index=ones(size(log_likelihood))[, kwargs...]\n+        chain_index=ones(size(log_likelihood)), \n+        source=\"mcmc\",\n+        [, kwargs...]\n     )\n \n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n score.\n \n # Arguments\n-- `log_likelihood::AbstractArray`: An array or matrix of log-likelihood values indexed as \n+- `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as \n `[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if \n-all data points were drawn from a single chain.\n+all posterior samples were drawn from a single chain.\n - `args...`: Positional arguments to be passed to [`psis`](@ref).\n-- `chain_index`: A vector of integers specifying which chain each iteration belongs to. For\n+- `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]` \n belongs to the second chain.\n - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \"\"\"\n-function psis_loo(log_likelihood::T, args...; kwargs...) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n+function psis_loo(log_likelihood::T, args...; \n+        kwargs...\n+    ) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n \n-    source = lowercase(string(source))\n     dims = size(log_likelihood)\n     data_size = dims[1]\n     mcmc_count = dims[2] * dims[3]  # total number of samples from posterior\n     log_count = log(mcmc_count)\n"
                },
                {
                    "date": 1626478555198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,14 +9,17 @@\n \n const LOO_METHODS = subtypes(AbstractLooMethod)\n \n \"\"\"\n-    function loo(args...; method=PsisLooMethod(), kwargs...) -> \n+    function loo(args...; method=PsisLooMethod(), kwargs...) -> PsisLoo\n \n Compute the approximate leave-one-out cross-validation score using the specified method.\n \n Currently, this function only serves to call `psis_loo`, but this could change in the\n-future.\n+future. The default methods or return type may change without warning; thus, we recommend\n+using `psis_loo` instead if reproducibility is required.\n+\n+See also: [`psis_loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function loo(args...; method=PsisLooMethod(), kwargs...)\n     if typeof(method) ∈ LOO_METHODS\n         return psis_loo(args...; kwargs...)\n@@ -26,13 +29,11 @@\n end\n \n \n \"\"\"\n-    function psis_loo(log_likelihood[, args...];\n-        chain_index=ones(size(log_likelihood)), \n-        source=\"mcmc\",\n-        [, kwargs...]\n-    )\n+    function psis_loo(log_likelihood::Array{Float} [, args...];\n+        source::String=\"mcmc\" [, chain_index::Vector{Int}, kwargs...]\n+    ) -> PsisLoo\n \n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n score.\n \n@@ -44,8 +45,10 @@\n - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]` \n belongs to the second chain.\n - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n+\n+See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function psis_loo(log_likelihood::T, args...; \n         kwargs...\n     ) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n"
                },
                {
                    "date": 1626479743512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,10 +70,11 @@\n \n \n     @tullio pointwise_ev[i] := weights[i, j, k] * exp(log_likelihood[i, j, k]) |> log\n     @tullio pointwise_naive[i] := exp(log_likelihood[i, j, k] - log_count) |> log\n-    @tullio pointwise_mcse[i] := (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n-    @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n+    @tullio pointwise_mcse[i] := \n+        (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n+    @tturbo @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n     \n \n     pointwise_p_eff = pointwise_naive - pointwise_ev\n     pointwise = KeyedArray(hcat(\n@@ -103,9 +104,9 @@\n     table(:total_score, :SE, :) .= ev_se = sqrt(varm(pointwise_ev, ev_avg) * data_size)\n     table(:avg_score, :SE, :) .= ev_se / data_size\n     table(:overfit, :SE, :) .= sqrt(varm(pointwise_p_eff, p_eff / data_size) * data_size)\n \n-    return PsisLoo(table, pointwise, psis_object);\n+    return PsisLoo(table, pointwise, psis_object)\n \n end\n \n \n"
                },
                {
                    "date": 1626484831562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,22 +37,23 @@\n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n score.\n \n # Arguments\n-- `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as \n-`[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if \n-all posterior samples were drawn from a single chain.\n-- `args...`: Positional arguments to be passed to [`psis`](@ref).\n-- `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n-instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]` \n-belongs to the second chain.\n-- `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \n+  - `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as\n+    `[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if\n+    all posterior samples were drawn from a single chain.\n+  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n+  - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n+    instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]`\n+    belongs to the second chain.\n+  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n+\n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n-function psis_loo(log_likelihood::T, args...; \n-        kwargs...\n-    ) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n+function psis_loo(\n+    log_likelihood::T, args...; kwargs...\n+) where {F <: AbstractFloat, T <: AbstractArray{F, 3}}\n \n     dims = size(log_likelihood)\n     data_size = dims[1]\n     mcmc_count = dims[2] * dims[3]  # total number of samples from posterior\n@@ -70,34 +71,26 @@\n \n \n     @tullio pointwise_ev[i] := weights[i, j, k] * exp(log_likelihood[i, j, k]) |> log\n     @tullio pointwise_naive[i] := exp(log_likelihood[i, j, k] - log_count) |> log\n-    @tullio pointwise_mcse[i] := \n+    @tullio pointwise_mcse[i] :=\n         (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n     @tturbo @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n-    \n \n+\n     pointwise_p_eff = pointwise_naive - pointwise_ev\n-    pointwise = KeyedArray(hcat(\n-                    pointwise_ev,\n-                    pointwise_mcse,\n-                    pointwise_p_eff,\n-                    ξ,\n-                );\n-                data=1:length(pointwise_ev),\n-                statistic=[\n-                    :est_score, \n-                    :mcse, \n-                    :est_overfit, \n-                    :pareto_k\n-                ]\n+    pointwise = KeyedArray(\n+        hcat(pointwise_ev, pointwise_mcse, pointwise_p_eff, ξ);\n+        data=1:length(pointwise_ev),\n+        statistic=[:est_score, :mcse, :est_overfit, :pareto_k],\n     )\n-                \n-    table = KeyedArray(similar(log_likelihood, 3, 2); \n+\n+    table = KeyedArray(\n+        similar(log_likelihood, 3, 2);\n         criterion=[:total_score, :overfit, :avg_score],\n         estimate=[:Estimate, :SE],\n-        )\n-    \n+    )\n+\n     table(:total_score, :Estimate, :) .= ev_loo = sum(pointwise_ev)\n     table(:avg_score, :Estimate, :) .= ev_avg = ev_loo / data_size\n     table(:overfit, :Estimate, :) .= p_eff = sum(pointwise_p_eff)\n \n@@ -109,12 +102,13 @@\n \n end\n \n \n-function psis_loo(log_likelihood::T, \n+function psis_loo(\n+    log_likelihood::T,\n     args...;\n     chain_index::AbstractVector=ones(size(log_likelihood, 1)),\n-    kwargs...\n-) where {F<:AbstractFloat,T<:AbstractMatrix{F}}\n+    kwargs...,\n+) where {F <: AbstractFloat, T <: AbstractMatrix{F}}\n     new_log_ratios = _convert_to_array(log_likelihood, chain_index)\n     return psis_loo(new_log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626539729622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n Compute the approximate leave-one-out cross-validation score using the specified method.\n \n Currently, this function only serves to call `psis_loo`, but this could change in the\n future. The default methods or return type may change without warning; thus, we recommend\n-using `psis_loo` instead if reproducibility is required.\n+using `psis_loo` instead if reproducibility.\n \n See also: [`psis_loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function loo(args...; method=PsisLooMethod(), kwargs...)\n@@ -37,23 +37,22 @@\n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n score.\n \n # Arguments\n+- `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as \n+`[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if \n+all posterior samples were drawn from a single chain.\n+- `args...`: Positional arguments to be passed to [`psis`](@ref).\n+- `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n+instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]` \n+belongs to the second chain.\n+- `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \n-  - `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as\n-    `[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if\n-    all posterior samples were drawn from a single chain.\n-  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n-  - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n-    instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]`\n-    belongs to the second chain.\n-  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n-\n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n-function psis_loo(\n-    log_likelihood::T, args...; kwargs...\n-) where {F <: AbstractFloat, T <: AbstractArray{F, 3}}\n+function psis_loo(log_likelihood::T, args...; \n+        kwargs...\n+    ) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n \n     dims = size(log_likelihood)\n     data_size = dims[1]\n     mcmc_count = dims[2] * dims[3]  # total number of samples from posterior\n@@ -71,44 +70,50 @@\n \n \n     @tullio pointwise_ev[i] := weights[i, j, k] * exp(log_likelihood[i, j, k]) |> log\n     @tullio pointwise_naive[i] := exp(log_likelihood[i, j, k] - log_count) |> log\n-    @tullio pointwise_mcse[i] :=\n-        (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n-    @tturbo @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n+    @tullio pointwise_mcse[i] := (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n+    @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n+    \n \n-\n     pointwise_p_eff = pointwise_naive - pointwise_ev\n-    pointwise = KeyedArray(\n-        hcat(pointwise_ev, pointwise_mcse, pointwise_p_eff, ξ);\n-        data=1:length(pointwise_ev),\n-        statistic=[:est_score, :mcse, :est_overfit, :pareto_k],\n+    pointwise = KeyedArray(hcat(\n+                    pointwise_ev,\n+                    pointwise_mcse,\n+                    pointwise_p_eff,\n+                    ξ,\n+                );\n+                data=1:length(pointwise_ev),\n+                statistic=[\n+                    :est_score, \n+                    :mcse, \n+                    :est_overfit, \n+                    :pareto_k\n+                ]\n     )\n-\n-    table = KeyedArray(\n-        similar(log_likelihood, 3, 2);\n+                \n+    table = KeyedArray(similar(log_likelihood, 3, 2); \n         criterion=[:total_score, :overfit, :avg_score],\n         estimate=[:Estimate, :SE],\n-    )\n-\n+        )\n+    \n     table(:total_score, :Estimate, :) .= ev_loo = sum(pointwise_ev)\n     table(:avg_score, :Estimate, :) .= ev_avg = ev_loo / data_size\n     table(:overfit, :Estimate, :) .= p_eff = sum(pointwise_p_eff)\n \n     table(:total_score, :SE, :) .= ev_se = sqrt(varm(pointwise_ev, ev_avg) * data_size)\n     table(:avg_score, :SE, :) .= ev_se / data_size\n     table(:overfit, :SE, :) .= sqrt(varm(pointwise_p_eff, p_eff / data_size) * data_size)\n \n-    return PsisLoo(table, pointwise, psis_object)\n+    return PsisLoo(table, pointwise, psis_object);\n \n end\n \n \n-function psis_loo(\n-    log_likelihood::T,\n+function psis_loo(log_likelihood::T, \n     args...;\n     chain_index::AbstractVector=ones(size(log_likelihood, 1)),\n-    kwargs...,\n-) where {F <: AbstractFloat, T <: AbstractMatrix{F}}\n+    kwargs...\n+) where {F<:AbstractFloat,T<:AbstractMatrix{F}}\n     new_log_ratios = _convert_to_array(log_likelihood, chain_index)\n     return psis_loo(new_log_ratios, args...; kwargs...)\n end\n"
                },
                {
                    "date": 1626539740686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n Compute the approximate leave-one-out cross-validation score using the specified method.\n \n Currently, this function only serves to call `psis_loo`, but this could change in the\n future. The default methods or return type may change without warning; thus, we recommend\n-using `psis_loo` instead if reproducibility is required.\n+using `psis_loo` instead if reproducibility.\n \n See also: [`psis_loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n function loo(args...; method=PsisLooMethod(), kwargs...)\n@@ -37,23 +37,22 @@\n Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation\n score.\n \n # Arguments\n+- `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as \n+`[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if \n+all posterior samples were drawn from a single chain.\n+- `args...`: Positional arguments to be passed to [`psis`](@ref).\n+- `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n+instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]` \n+belongs to the second chain.\n+- `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n \n-  - `log_likelihood::Array`: An array or matrix of log-likelihood values indexed as\n-    `[data, step, chain]`. The chain argument can be left off if `chain_index` is provided or if\n-    all posterior samples were drawn from a single chain.\n-  - `args...`: Positional arguments to be passed to [`psis`](@ref).\n-  - `chain_index::Vector`: A vector of integers specifying which chain each iteration belongs to. For\n-    instance, `chain_index[iteration]` should return `2` if `log_likelihood[:, step]`\n-    belongs to the second chain.\n-  - `kwargs...`: Keyword arguments to be passed to [`psis`](@ref).\n-\n See also: [`psis`](@ref), [`loo`](@ref), [`PsisLoo`](@ref).\n \"\"\"\n-function psis_loo(\n-    log_likelihood::T, args...; kwargs...\n-) where {F <: AbstractFloat, T <: AbstractArray{F, 3}}\n+function psis_loo(log_likelihood::T, args...; \n+        kwargs...\n+    ) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n \n     dims = size(log_likelihood)\n     data_size = dims[1]\n     mcmc_count = dims[2] * dims[3]  # total number of samples from posterior\n@@ -71,44 +70,50 @@\n \n \n     @tullio pointwise_ev[i] := weights[i, j, k] * exp(log_likelihood[i, j, k]) |> log\n     @tullio pointwise_naive[i] := exp(log_likelihood[i, j, k] - log_count) |> log\n-    @tullio pointwise_mcse[i] :=\n-        (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n-    @tturbo @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n+    @tullio pointwise_mcse[i] := (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n+    @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n+    \n \n-\n     pointwise_p_eff = pointwise_naive - pointwise_ev\n-    pointwise = KeyedArray(\n-        hcat(pointwise_ev, pointwise_mcse, pointwise_p_eff, ξ);\n-        data=1:length(pointwise_ev),\n-        statistic=[:est_score, :mcse, :est_overfit, :pareto_k],\n+    pointwise = KeyedArray(hcat(\n+                    pointwise_ev,\n+                    pointwise_mcse,\n+                    pointwise_p_eff,\n+                    ξ,\n+                );\n+                data=1:length(pointwise_ev),\n+                statistic=[\n+                    :est_score, \n+                    :mcse, \n+                    :est_overfit, \n+                    :pareto_k\n+                ]\n     )\n-\n-    table = KeyedArray(\n-        similar(log_likelihood, 3, 2);\n+                \n+    table = KeyedArray(similar(log_likelihood, 3, 2); \n         criterion=[:total_score, :overfit, :avg_score],\n         estimate=[:Estimate, :SE],\n-    )\n-\n+        )\n+    \n     table(:total_score, :Estimate, :) .= ev_loo = sum(pointwise_ev)\n     table(:avg_score, :Estimate, :) .= ev_avg = ev_loo / data_size\n     table(:overfit, :Estimate, :) .= p_eff = sum(pointwise_p_eff)\n \n     table(:total_score, :SE, :) .= ev_se = sqrt(varm(pointwise_ev, ev_avg) * data_size)\n     table(:avg_score, :SE, :) .= ev_se / data_size\n     table(:overfit, :SE, :) .= sqrt(varm(pointwise_p_eff, p_eff / data_size) * data_size)\n \n-    return PsisLoo(table, pointwise, psis_object)\n+    return PsisLoo(table, pointwise, psis_object);\n \n end\n \n \n-function psis_loo(\n-    log_likelihood::T,\n+function psis_loo(log_likelihood::T, \n     args...;\n     chain_index::AbstractVector=ones(size(log_likelihood, 1)),\n-    kwargs...,\n-) where {F <: AbstractFloat, T <: AbstractMatrix{F}}\n+    kwargs...\n+) where {F<:AbstractFloat,T<:AbstractMatrix{F}}\n     new_log_ratios = _convert_to_array(log_likelihood, chain_index)\n     return psis_loo(new_log_ratios, args...; kwargs...)\n end\n"
                }
            ],
            "date": 1626310486785,
            "name": "Commit-0",
            "content": "using AxisKeys\nusing InteractiveUtils\nusing LoopVectorization\nusing Statistics\nusing Tullio\n\n\nexport loo, psis_loo\n\nconst LOO_METHODS = subtypes(AbstractLooMethod)\n\nfunction loo(args...; method=PsisLooMethod(), kwargs...)\n    if typeof(method) ∈ LOO_METHODS\n        return psis_loo(args...; kwargs...)\n    else\n        throw(ArgumentError(\"Invalid method provided. Valid methods are $LOO_METHODS\"))\n    end\nend\n\n\nfunction psis_loo(log_likelihood::T, \n    r_eff=similar(log_likelihood, 0);\n    source::Union{AbstractString,Symbol}=\"mcmc\", \n    log_weights::Bool=false\n) where {F<:AbstractFloat,T<:AbstractArray{F,3}}\n\n    source = lowercase(string(source))\n    dims = size(log_likelihood)\n    data_size = dims[1]\n    mcmc_count = dims[2] * dims[3]  # total number of samples from posterior\n    log_count = log(mcmc_count)\n\n\n    # TODO: Add a way of using score functions other than ELPD\n    # log_likelihood::ArrayType = similar(log_likelihood)\n    # log_likelihood .= score(log_likelihood)\n\n    psis_object = psis(-log_likelihood, r_eff; source=source, log_weights=log_weights)\n    weights = psis_object.weights\n    ξ = psis_object.pareto_k\n    r_eff = psis_object.r_eff\n\n\n    @tullio pointwise_ev[i] := weights[i, j, k] * exp(log_likelihood[i, j, k]) |> log\n    @tullio pointwise_naive[i] := exp(log_likelihood[i, j, k] - log_count) |> log\n    @tullio pointwise_mcse[i] := (weights[i, j, k] * (log_likelihood[i, j, k] - pointwise_ev[i]))^2\n    @. pointwise_mcse = sqrt(pointwise_mcse / r_eff)\n    \n\n    pointwise_p_eff = pointwise_naive - pointwise_ev\n    pointwise = KeyedArray(hcat(\n                    pointwise_ev,\n                    pointwise_mcse,\n                    pointwise_p_eff,\n                    ξ,\n                );\n                data=1:length(pointwise_ev),\n                statistic=[\n                    :est_score, \n                    :mcse, \n                    :est_overfit, \n                    :pareto_k\n                ]\n    )\n                \n    table = KeyedArray(similar(log_likelihood, 3, 2); \n        criterion=[:total_score, :overfit, :avg_score],\n        estimate=[:Estimate, :SE],\n        )\n    \n    table(:total_score, :Estimate, :) .= ev_loo = sum(pointwise_ev)\n    table(:avg_score, :Estimate, :) .= ev_avg = ev_loo / data_size\n    table(:overfit, :Estimate, :) .= p_eff = sum(pointwise_p_eff)\n\n    table(:total_score, :SE, :) .= ev_se = sqrt(varm(pointwise_ev, ev_avg) * data_size)\n    table(:avg_score, :SE, :) .= ev_se / data_size\n    table(:overfit, :SE, :) .= sqrt(varm(pointwise_p_eff, p_eff / data_size) * data_size)\n\n    return PsisLoo(table, pointwise, psis_object);\n\nend\n\n\nfunction psis_loo(log_likelihood::T, \n    r_eff=similar(log_likelihood, 0);\n    chain_index=ones(size(log_likelihood, 1)),\n    source::Union{AbstractString,Symbol}=\"mcmc\", \n    log_weights::Bool=false\n) where {F<:AbstractFloat,T<:AbstractMatrix{F}}\n    new_log_ratios = _convert_to_array(log_likelihood, chain_index)\n    return psis_loo(new_log_ratios, r_eff; source, log_weights)\nend\n"
        }
    ]
}