{
    "sourceFile": "src/AlgoSort.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1626722303957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626722367264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,14 @@\n-# Implements a sorting algorithm for internal use, based on SortingLab.jl\n+# Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n \n import StatsBase: BaseRadixSortSafeTypes\n \n \"\"\"\n     sorttwo!(vs, index)\n Sort both the `vs` and reorder `index` at the same. This allows for faster sortperm\n for radix sort.\n \"\"\"\n-function sorttwo!(vs::Vector{T}, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T # <:Union{BaseRadixSortSafeTypes}\n+function sorttwo!(vs::AbstractVector, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff)\n     # Input checking\n     if lo >= hi;  return (vs, index);  end\n     #println(vs)\n     o = Forward\n"
                },
                {
                    "date": 1626722779785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,6 @@\n # Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n \n-import StatsBase: BaseRadixSortSafeTypes\n-\n \"\"\"\n     sorttwo!(vs, index)\n Sort both the `vs` and reorder `index` at the same. This allows for faster sortperm\n for radix sort.\n@@ -29,9 +27,9 @@\n     len = hi-lo+1\n \n     index1 = similar(index)\n     ts=similar(vs)\n-    @turbo for j = 1:iters\n+    @inbounds for j = 1:iters\n         # Unroll first data iteration, check for degenerate case\n         v = uint_mapping(o, vs[hi])\n         idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n \n@@ -53,9 +51,9 @@\n         # println(cbin[idx])\n         cbin[idx] -= 1\n \n         # Finish the loop...        \n-        @inbounds for i in hi-1:-1:lo\n+         for i in hi-1:-1:lo\n             v = uint_mapping(o, vs[i])\n             idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n             ci = cbin[idx]\n             #println(ci)\n@@ -70,11 +68,11 @@\n \n     if isodd(swaps)\n         vs,ts = ts,vs\n         index, index1 = index1, index\n-        for i = lo:hi\n-            @inbounds vs[i] = ts[i]\n-            @inbounds index[i] = index1[i]\n+        @inbounds for i = lo:hi\n+            vs[i] = ts[i]\n+            index[i] = index1[i]\n         end\n     end\n     (vs, index)\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626723138825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,9 @@\n # Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n \n \"\"\"\n     sorttwo!(vs, index)\n-Sort both the `vs` and reorder `index` at the same. This allows for faster sortperm\n-for radix sort.\n+Sort both the `vs` and reorder `index` at the same.\n \"\"\"\n function sorttwo!(vs::AbstractVector, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff)\n     # Input checking\n     if lo >= hi;  return (vs, index);  end\n"
                },
                {
                    "date": 1626723533979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,6 +72,6 @@\n             vs[i] = ts[i]\n             index[i] = index1[i]\n         end\n     end\n-    (vs, index)\n+    return index\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626723824779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,14 @@\n-# Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n+# Implements a sorting algorithm for internal use, based on SortingLab.jl\n \n+import StatsBase: BaseRadixSortSafeTypes\n+\n \"\"\"\n     sorttwo!(vs, index)\n-Sort both the `vs` and reorder `index` at the same.\n+Sort both the `vs` and reorder `index` at the same. This allows for faster sortperm\n+for radix sort.\n \"\"\"\n-function sorttwo!(vs::AbstractVector, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff)\n+function sorttwo!(vs::Vector{T}, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T # <:Union{BaseRadixSortSafeTypes}\n     # Input checking\n     if lo >= hi;  return (vs, index);  end\n     #println(vs)\n     o = Forward\n@@ -26,9 +29,9 @@\n     len = hi-lo+1\n \n     index1 = similar(index)\n     ts=similar(vs)\n-    @inbounds for j = 1:iters\n+    @turbo for j = 1:iters\n         # Unroll first data iteration, check for degenerate case\n         v = uint_mapping(o, vs[hi])\n         idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n \n@@ -50,9 +53,9 @@\n         # println(cbin[idx])\n         cbin[idx] -= 1\n \n         # Finish the loop...        \n-         for i in hi-1:-1:lo\n+        @inbounds for i in hi-1:-1:lo\n             v = uint_mapping(o, vs[i])\n             idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n             ci = cbin[idx]\n             #println(ci)\n@@ -72,6 +75,6 @@\n             vs[i] = ts[i]\n             index[i] = index1[i]\n         end\n     end\n-    return index\n+    (vs, index)\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626723834664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,6 +75,7 @@\n             vs[i] = ts[i]\n             index[i] = index1[i]\n         end\n     end\n-    (vs, index)\n+    \n+    return index\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626723999498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,14 @@\n-# Implements a sorting algorithm for internal use, based on SortingLab.jl\n-\n-import StatsBase: BaseRadixSortSafeTypes\n-\n+# Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n \"\"\"\n     sorttwo!(vs, index)\n-Sort both the `vs` and reorder `index` at the same. This allows for faster sortperm\n-for radix sort.\n+Sort both the `vs` and reorder `index` at the same.\n \"\"\"\n-function sorttwo!(vs::Vector{T}, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T # <:Union{BaseRadixSortSafeTypes}\n-    # Input checking\n-    if lo >= hi;  return (vs, index);  end\n-    #println(vs)\n-    o = Forward\n+function sorttwo!(vs::AbstractVector)\n+    lo = 1\n+    hi = length(vs)\n+    RADIX_SIZE = 16\n+    RADIX_MASK = 0xffff\n \n     # Init\n     iters = ceil(Integer, sizeof(T)*8/RADIX_SIZE)\n     # number of buckets in the counting steuint_histp\n"
                },
                {
                    "date": 1626724103081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n \"\"\"\n     sorttwo!(vs, index)\n Sort both the `vs` and reorder `index` at the same.\n \"\"\"\n-function sorttwo!(vs::AbstractVector)\n+function sorttwo!(vs::AbstractVector{T<:AbstractFloat})\n     lo = 1\n     hi = length(vs)\n     RADIX_SIZE = 16\n     RADIX_MASK = 0xffff\n"
                },
                {
                    "date": 1626724134333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n     len = hi-lo+1\n \n     index1 = similar(index)\n     ts=similar(vs)\n-    @turbo for j = 1:iters\n+    @inbounds for j = 1:iters\n         # Unroll first data iteration, check for degenerate case\n         v = uint_mapping(o, vs[hi])\n         idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n \n"
                },
                {
                    "date": 1626725148582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n # Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n \"\"\"\n-    sorttwo!(vs, index)\n-Sort both the `vs` and reorder `index` at the same.\n+    sorttwo!(array, index)\n+Sort both the `array` and reorder `index` at the same.\n \"\"\"\n-function sorttwo!(vs::AbstractVector{T<:AbstractFloat})\n+function sorttwo!(array::AbstractVector{T<:AbstractFloat})\n     lo = 1\n-    hi = length(vs)\n+    len = length(array)\n     RADIX_SIZE = 16\n     RADIX_MASK = 0xffff\n \n     # Init\n@@ -14,22 +14,21 @@\n     # number of buckets in the counting steuint_histp\n     nbuckets = 2^RADIX_SIZE\n \n     # Histogram for each element, radix\n-    bin = uint_hist(vs, RADIX_SIZE, RADIX_MASK)\n+    bin = uint_hist(array, RADIX_SIZE, RADIX_MASK)\n \n     # bin = zeros(UInt32, nbuckets, iters)\n     # if lo > 1;  bin[1,:] = lo-1;  end\n \n     # Sort!\n     swaps = 0\n-    len = hi-lo+1\n \n-    index1 = similar(index)\n-    ts=similar(vs)\n-    @inbounds for j = 1:iters\n+    index1 = index = 1:len\n+    ts=similar(array)\n+    @inbounds for j in 1:iters\n         # Unroll first data iteration, check for degenerate case\n-        v = uint_mapping(o, vs[hi])\n+        v = uint_mapping(o, array[len])\n         idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n \n         # are all values the same at this radix?\n         if bin[idx,j] == len;  continue;  end\n@@ -42,36 +41,55 @@\n             cbin[i] = cbin[i-1] + bin[i,j]\n         end\n \n         ci = cbin[idx]\n-        #println((ci, hi))\n-        ts[ci] = vs[hi]\n-        index1[ci] = index[hi]\n+        #println((ci, len))\n+        ts[ci] = array[len]\n+        index1[ci] = index[len]\n         # println(cbin[idx])\n         cbin[idx] -= 1\n \n         # Finish the loop...        \n-        @inbounds for i in hi-1:-1:lo\n-            v = uint_mapping(o, vs[i])\n+        @inbounds for i in len-1:-1:lo\n+            v = uint_mapping(o, array[i])\n             idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n             ci = cbin[idx]\n             #println(ci)\n-            ts[ci] = vs[i]\n+            ts[ci] = array[i]\n             index1[ci] = index[i]\n             cbin[idx] -= 1\n         end\n-        vs,ts = ts,vs\n+        array,ts = ts,array\n         index, index1 = index1, index\n         swaps += 1\n     end\n \n     if isodd(swaps)\n-        vs,ts = ts,vs\n+        array, ts = ts, array\n         index, index1 = index1, index\n-        @inbounds for i = lo:hi\n-            vs[i] = ts[i]\n+        @inbounds for i in eachindex(array)\n+            array[i] = ts[i]\n             index[i] = index1[i]\n         end\n     end\n     \n     return index\n+end\n+\n+\n+\"\"\"\n+    uint_hist(bits, [RADIX_SIZE = 16, RADIX_MASK = 0xffff])\n+    \n+Computes a histogram (counts) for the vector RADIX_SIZE bits at a time. E.g. if eltype(bits)\n+is UInt64 and RADIX_SIZE is 16 then 4 histograms are created for each of the 16 bit chunks.\n+\"\"\"\n+function uint_hist(bits::Vector{T}, RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T\n+    iter = ceil(Integer, sizeof(T)*8/RADIX_SIZE)\n+    hist = zeros(UInt32, 2^RADIX_SIZE, iter)\n+\n+    for j = 1:length(bits)\n+        for i = 0:iter-1\n+            @inbounds hist[1+Int((uint_mapping(bits[j]) >> (i * RADIX_SIZE)) & RADIX_MASK), i+1] += 1\n+        end\n+    end\n+    hist\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626725211399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,12 +19,14 @@\n \n     # bin = zeros(UInt32, nbuckets, iters)\n     # if lo > 1;  bin[1,:] = lo-1;  end\n \n+    index1 = 1:len\n+    index = 1:len\n+\n     # Sort!\n     swaps = 0\n \n-    index1 = index = 1:len\n     ts=similar(array)\n     @inbounds for j in 1:iters\n         # Unroll first data iteration, check for degenerate case\n         v = uint_mapping(o, array[len])\n"
                },
                {
                    "date": 1626725292730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n \"\"\"\n     sorttwo!(array, index)\n Sort both the `array` and reorder `index` at the same.\n \"\"\"\n-function sorttwo!(array::AbstractVector{T<:AbstractFloat})\n+function sorttwo!(array::AbstractVector{T}) where {T<:AbstractFloat}\n     lo = 1\n     len = length(array)\n     RADIX_SIZE = 16\n     RADIX_MASK = 0xffff\n"
                },
                {
                    "date": 1626725379649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,9 @@\n     \n Computes a histogram (counts) for the vector RADIX_SIZE bits at a time. E.g. if eltype(bits)\n is UInt64 and RADIX_SIZE is 16 then 4 histograms are created for each of the 16 bit chunks.\n \"\"\"\n-function uint_hist(bits::Vector{T}, RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T\n+function uint_hist(bits::AbstractVector{T}, RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T\n     iter = ceil(Integer, sizeof(T)*8/RADIX_SIZE)\n     hist = zeros(UInt32, 2^RADIX_SIZE, iter)\n \n     for j = 1:length(bits)\n"
                },
                {
                    "date": 1626725403446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,9 @@\n     \n Computes a histogram (counts) for the vector RADIX_SIZE bits at a time. E.g. if eltype(bits)\n is UInt64 and RADIX_SIZE is 16 then 4 histograms are created for each of the 16 bit chunks.\n \"\"\"\n-function uint_hist(bits::AbstractVector{T}, RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T\n+function uint_hist(bits::AbstractVector{T}, RADIX_SIZE = 16, RADIX_MASK = 0xffff) where {T<:AbstractFloat}\n     iter = ceil(Integer, sizeof(T)*8/RADIX_SIZE)\n     hist = zeros(UInt32, 2^RADIX_SIZE, iter)\n \n     for j = 1:length(bits)\n"
                },
                {
                    "date": 1626725481170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n \n     ts=similar(array)\n     @inbounds for j in 1:iters\n         # Unroll first data iteration, check for degenerate case\n-        v = uint_mapping(o, array[len])\n+        v = uint_mapping(lo, array[len])\n         idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n \n         # are all values the same at this radix?\n         if bin[idx,j] == len;  continue;  end\n"
                },
                {
                    "date": 1626726299804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,18 @@\n # Implements a sorting algorithm for internal use, based on SortingLab.jl's radix sort\n+\n+\n+export uint_mapping\n+\n+import SortingAlgorithms: uint_mapping\n+\n+uint_mapping(x) = uint_mapping(Base.Forward, x)\n+\n+uint_mapping(::Missing) = UInt(2)^8sizeof(UInt)-1\n+\n+uint_mapping(_, ::Missing) = UInt(2)^8sizeof(UInt)-1\n+\n+\n \"\"\"\n     sorttwo!(array, index)\n Sort both the `array` and reorder `index` at the same.\n \"\"\"\n@@ -93,5 +106,6 @@\n             @inbounds hist[1+Int((uint_mapping(bits[j]) >> (i * RADIX_SIZE)) & RADIX_MASK), i+1] += 1\n         end\n     end\n     hist\n-end\n\\ No newline at end of file\n+end\n+\n"
                }
            ],
            "date": 1626722303957,
            "name": "Commit-0",
            "content": "# Implements a sorting algorithm for internal use, based on SortingLab.jl\n\nimport StatsBase: BaseRadixSortSafeTypes\n\n\"\"\"\n    sorttwo!(vs, index)\nSort both the `vs` and reorder `index` at the same. This allows for faster sortperm\nfor radix sort.\n\"\"\"\nfunction sorttwo!(vs::Vector{T}, index, lo::Int = 1, hi::Int=length(vs), RADIX_SIZE = 16, RADIX_MASK = 0xffff) where T # <:Union{BaseRadixSortSafeTypes}\n    # Input checking\n    if lo >= hi;  return (vs, index);  end\n    #println(vs)\n    o = Forward\n\n    # Init\n    iters = ceil(Integer, sizeof(T)*8/RADIX_SIZE)\n    # number of buckets in the counting steuint_histp\n    nbuckets = 2^RADIX_SIZE\n\n    # Histogram for each element, radix\n    bin = uint_hist(vs, RADIX_SIZE, RADIX_MASK)\n\n    # bin = zeros(UInt32, nbuckets, iters)\n    # if lo > 1;  bin[1,:] = lo-1;  end\n\n    # Sort!\n    swaps = 0\n    len = hi-lo+1\n\n    index1 = similar(index)\n    ts=similar(vs)\n    @turbo for j = 1:iters\n        # Unroll first data iteration, check for degenerate case\n        v = uint_mapping(o, vs[hi])\n        idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n\n        # are all values the same at this radix?\n        if bin[idx,j] == len;  continue;  end\n\n        # cbin = cumsum(bin[:,j])\n        # tries to achieve the above one-liner with more efficiency\n        cbin = zeros(UInt32, nbuckets)\n        cbin[1] = bin[1,j]\n        @inbounds for i in 2:nbuckets\n            cbin[i] = cbin[i-1] + bin[i,j]\n        end\n\n        ci = cbin[idx]\n        #println((ci, hi))\n        ts[ci] = vs[hi]\n        index1[ci] = index[hi]\n        # println(cbin[idx])\n        cbin[idx] -= 1\n\n        # Finish the loop...        \n        @inbounds for i in hi-1:-1:lo\n            v = uint_mapping(o, vs[i])\n            idx = Int((v >> ((j-1)*RADIX_SIZE)) & RADIX_MASK) + 1\n            ci = cbin[idx]\n            #println(ci)\n            ts[ci] = vs[i]\n            index1[ci] = index[i]\n            cbin[idx] -= 1\n        end\n        vs,ts = ts,vs\n        index, index1 = index1, index\n        swaps += 1\n    end\n\n    if isodd(swaps)\n        vs,ts = ts,vs\n        index, index1 = index1, index\n        for i = lo:hi\n            @inbounds vs[i] = ts[i]\n            @inbounds index[i] = index1[i]\n        end\n    end\n    (vs, index)\nend"
        }
    ]
}